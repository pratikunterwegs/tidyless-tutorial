[
["index.html", "TRES Tidyverse Tutorial Outline", " TRES Tidyverse Tutorial Raphael and Pratik 2020-05-20 Outline This is the readable version of the TRES tidyverse tutorial, with these sections: Reading data and string manipulation with readr, stringr, and glue The new data frames with tibble and wrangling them into shape with tidyr Manipulating data with dplyr Iteration and functional programming with purrr Plotting with ggplot2 "],
["reading-files-and-string-manipulation.html", "Section 1 Reading files and string manipulation 1.1 Section on readr 1.2 String manipulation with stringr 1.3 String interpolation with glue", " Section 1 Reading files and string manipulation library(readr) library(stringr) library(glue) 1.1 Section on readr 1.2 String manipulation with stringr stringr is the tidyverse package for string manipulation, and exists in an interesting symbiosis with the stringi package. For the most part, stringr is a wrapper around stringi, and is almost always more than sufficient for day-to-day needs. stringr functions begin with str_. 1.2.1 Putting strings together Concatenate two strings with str_c, and duplicate strings with str_dup. Flatten a list or vector of strings using str_flatten. # str_c works like paste(), choose a separator str_c(&quot;this string&quot;, &quot;this other string&quot;, sep = &quot;_&quot;) ## [1] &quot;this string_this other string&quot; # str_dup works like rep str_dup(&quot;this string&quot;, times = 3) ## [1] &quot;this stringthis stringthis string&quot; # str_flatten works on lists and vectors str_flatten(string = as.list(letters), collapse = &quot;_&quot;) ## [1] &quot;a_b_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z&quot; str_flatten(string = letters, collapse = &quot;-&quot;) ## [1] &quot;a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z&quot; str_flatten is especially useful when displaying the type of an object that returns a list when class is called on it. # get the class of a tibble and display it as a single string class_tibble = class(tibble::tibble(a = 1)) str_flatten(string = class_tibble, collapse = &quot;, &quot;) ## [1] &quot;tbl_df, tbl, data.frame&quot; 1.2.2 Detecting strings Count the frequency of a pattern in a string with str_count. Returns an inteegr. Detect whether a pattern exists in a string with str_detect. Returns a logical and can be used as a predicate. Both are vectorised, i.e, automatically applied to a vector of arguments. # there should be 5 a-s here str_count(string = &quot;ababababa&quot;, pattern = &quot;a&quot;) ## [1] 5 # vectorise over the input string # this should return a vector of length 2, with integers 5 and 3 str_count(string = c(&quot;ababbababa&quot;, &quot;banana&quot;), pattern = &quot;a&quot;) ## [1] 5 3 # vectorise over the pattern to count both a-s and b-s str_count(string = &quot;ababababa&quot;, pattern = c(&quot;a&quot;, &quot;b&quot;)) ## [1] 5 4 Vectorising over both string and pattern works as expected. # vectorise over both string and pattern # counts a-s in first input, and b-s in the second str_count(string = c(&quot;ababababa&quot;, &quot;banana&quot;), pattern = c(&quot;a&quot;, &quot;b&quot;)) ## [1] 5 1 # provide a longer pattern vector to search for both a-s and b-s in both inputs str_count(string = c(&quot;ababababa&quot;, &quot;banana&quot;), pattern = c(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;)) ## [1] 5 1 4 3 str_locate locates the search pattern in a string, and returns the start and end as a two column matrix. # the behaviour of both str_locate and str_locate_all is # to find the first match by default str_locate(string = &quot;banana&quot;, pattern = &quot;ana&quot;) ## start end ## [1,] 2 4 # str_detect detects a sequence in a string str_detect(string = &quot;Bananageddon is coming!&quot;, pattern = &quot;na&quot;) ## [1] TRUE # str_detect is also vectorised and returns a two-element logical vector str_detect(string = &quot;Bananageddon is coming!&quot;, pattern = c(&quot;na&quot;, &quot;don&quot;)) ## [1] TRUE TRUE # use any or all to convert a multi-element logical to a single logical # here we ask if either of the patterns is detected any(str_detect(string = &quot;Bananageddon is coming!&quot;, pattern = c(&quot;na&quot;, &quot;don&quot;))) ## [1] TRUE Detect whether a string starts or ends with a pattern. Also vectorised. Both have a negate argument, which returns the negative, i.e., returns FALSE if the search pattern is detected. # taken straight from the examples, because they suffice fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;pineapple&quot;) # str_detect looks at the first character str_starts(fruit, &quot;p&quot;) ## [1] FALSE FALSE TRUE TRUE # str_ends looks at the last character str_ends(fruit, &quot;e&quot;) ## [1] TRUE FALSE FALSE TRUE # an example of negate = TRUE str_ends(fruit, &quot;e&quot;, negate = TRUE) ## [1] FALSE TRUE TRUE FALSE str_subset [WHICH IS NOT RELATED TO str_sub] helps with subsetting a character vector based on a str_detect predicate. In the example, all elements containing “banana” are subset. str_which has the same logic except that it returns the vector position and not the elements. # should return a subset vector containing the first two elements str_subset(c(&quot;banana&quot;, &quot;bananageddon is coming&quot;, &quot;applegeddon is not real&quot;), pattern = &quot;banana&quot;) ## [1] &quot;banana&quot; &quot;bananageddon is coming&quot; # returns an integer vector str_which(c(&quot;banana&quot;, &quot;bananageddon is coming&quot;, &quot;applegeddon is not real&quot;), pattern = &quot;banana&quot;) ## [1] 1 2 1.2.3 Matching strings str_match returns all positive matches of the patttern in the string. The return type is a list, with one element per search pattern. A simple case is shown below where the search pattern is the phrase “banana”. str_match(string = c(&quot;banana&quot;, &quot;bananageddon&quot;, &quot;bananas are bad&quot;), pattern = &quot;banana&quot;) ## [,1] ## [1,] &quot;banana&quot; ## [2,] &quot;banana&quot; ## [3,] &quot;banana&quot; The search pattern can be extended to look for multiple subsets of the search pattern. Consider searching for dates and times. Here, the search pattern is a regex pattern that looks for a set of four digits (\\\\d{4}) and a month name (\\\\w+) seperated by a hyphen. There’s much more to be explored in dealing with dates and times in [lubridate](https://lubridate.tidyverse.org/), another tidyverse package. The return type is a list, each element is a character matrix where the first column is the string subset matching the full search pattern, and then as many columns as there are parts to the search pattern. The parts of interest in the search pattern are indicated by wrapping them in parentheses. For example, in the case below, wrapping [-.] in parentheses will turn it into a distinct part of the search pattern. # first with [-.] treated simply as a separator str_match(string = c(&quot;1970-somemonth-01&quot;, &quot;1990-anothermonth-01&quot;, &quot;2010-thismonth-01&quot;), pattern = &quot;(\\\\d{4})[-.](\\\\w+)&quot;) ## [,1] [,2] [,3] ## [1,] &quot;1970-somemonth&quot; &quot;1970&quot; &quot;somemonth&quot; ## [2,] &quot;1990-anothermonth&quot; &quot;1990&quot; &quot;anothermonth&quot; ## [3,] &quot;2010-thismonth&quot; &quot;2010&quot; &quot;thismonth&quot; # then with [-.] actively searched for str_match(string = c(&quot;1970-somemonth-01&quot;, &quot;1990-anothermonth-01&quot;, &quot;2010-thismonth-01&quot;), pattern = &quot;(\\\\d{4})([-.])(\\\\w+)&quot;) ## [,1] [,2] [,3] [,4] ## [1,] &quot;1970-somemonth&quot; &quot;1970&quot; &quot;-&quot; &quot;somemonth&quot; ## [2,] &quot;1990-anothermonth&quot; &quot;1990&quot; &quot;-&quot; &quot;anothermonth&quot; ## [3,] &quot;2010-thismonth&quot; &quot;2010&quot; &quot;-&quot; &quot;thismonth&quot; Multiple possible matches are dealt with using str_match_all. An example case is uncertainty in date-time in raw data, where the date has been entered as 1970-somemonth-01 or 1970/anothermonth/01. The return type is a list, with one element per input string. Each element is a character matrix, where each row is one possible match, and each column after the first (the full match) corresponds to the parts of the search pattern. # first with a single date entry str_match_all(string = c(&quot;1970-somemonth-01 or maybe 1990/anothermonth/01&quot;), pattern = &quot;(\\\\d{4})[\\\\-\\\\/]([a-z]+)&quot;) ## [[1]] ## [,1] [,2] [,3] ## [1,] &quot;1970-somemonth&quot; &quot;1970&quot; &quot;somemonth&quot; ## [2,] &quot;1990/anothermonth&quot; &quot;1990&quot; &quot;anothermonth&quot; # then with multiple date entries str_match_all(string = c(&quot;1970-somemonth-01 or maybe 1990/anothermonth/01&quot;, &quot;1990-somemonth-01 or maybe 2001/anothermonth/01&quot;), pattern = &quot;(\\\\d{4})[\\\\-\\\\/]([a-z]+)&quot;) ## [[1]] ## [,1] [,2] [,3] ## [1,] &quot;1970-somemonth&quot; &quot;1970&quot; &quot;somemonth&quot; ## [2,] &quot;1990/anothermonth&quot; &quot;1990&quot; &quot;anothermonth&quot; ## ## [[2]] ## [,1] [,2] [,3] ## [1,] &quot;1990-somemonth&quot; &quot;1990&quot; &quot;somemonth&quot; ## [2,] &quot;2001/anothermonth&quot; &quot;2001&quot; &quot;anothermonth&quot; 1.2.4 Simpler pattern extraction The full functionality of str_match_* can be boiled down to the most common use case, extracting one or more full matches of the search pattern using str_extract and str_extract_all respectively. str_extract returns a character vector with the same length as the input string vector, while str_extract_all returns a list, with a character vector whose elements are the matches. # extracting the first full match using str_extract str_extract(string = c(&quot;1970-somemonth-01 or maybe 1990/anothermonth/01&quot;, &quot;1990-somemonth-01 or maybe 2001/anothermonth/01&quot;), pattern = &quot;(\\\\d{4})[\\\\-\\\\/]([a-z]+)&quot;) ## [1] &quot;1970-somemonth&quot; &quot;1990-somemonth&quot; # extracting all full matches using str_extract all str_extract_all(string = c(&quot;1970-somemonth-01 or maybe 1990/anothermonth/01&quot;, &quot;1990-somemonth-01 or maybe 2001/anothermonth/01&quot;), pattern = &quot;(\\\\d{4})[\\\\-\\\\/]([a-z]+)&quot;) ## [[1]] ## [1] &quot;1970-somemonth&quot; &quot;1990/anothermonth&quot; ## ## [[2]] ## [1] &quot;1990-somemonth&quot; &quot;2001/anothermonth&quot; 1.2.5 Breaking strings apart str_split, str_sub, In the above date-time example, when reading filenames from a path, or when working sequences separated by a known pattern generally, str_split can help separate elements of interest. The return type is a list similar to str_match. # split on either a hyphen or a forward slash str_split(string = c(&quot;1970-somemonth-01&quot;, &quot;1990/anothermonth/01&quot;), pattern = &quot;[\\\\-\\\\/]&quot;) ## [[1]] ## [1] &quot;1970&quot; &quot;somemonth&quot; &quot;01&quot; ## ## [[2]] ## [1] &quot;1990&quot; &quot;anothermonth&quot; &quot;01&quot; This can be useful in recovering simulation parameters from a filename, but may require some knowledge of regex. # assume a simulation output file filename = &quot;sim_param1_0.01_param2_0.05_param3_0.01.ext&quot; # not quite there str_split(filename, pattern = &quot;_&quot;) ## [[1]] ## [1] &quot;sim&quot; &quot;param1&quot; &quot;0.01&quot; &quot;param2&quot; &quot;0.05&quot; &quot;param3&quot; &quot;0.01.ext&quot; # not really str_split(filename, pattern = &quot;sim_&quot;) ## [[1]] ## [1] &quot;&quot; ## [2] &quot;param1_0.01_param2_0.05_param3_0.01.ext&quot; # getting there but still needs work str_split(filename, pattern = &quot;(sim_)|_*param\\\\d{1}_|(.ext)&quot;) ## [[1]] ## [1] &quot;&quot; &quot;&quot; &quot;0.01&quot; &quot;0.05&quot; &quot;0.01&quot; &quot;&quot; str_split_fixed split the string into as many pieces as specified, and can be especially useful dealing with filepaths. # split on either a hyphen or a forward slash str_split_fixed(string = &quot;dir_level_1/dir_level_2/file.ext&quot;, pattern = &quot;/&quot;, n = 2) ## [,1] [,2] ## [1,] &quot;dir_level_1&quot; &quot;dir_level_2/file.ext&quot; 1.2.6 Replacing string elements str_replace is intended to replace the search pattern, and can be co-opted into the task of recovering simulation parameters or other data from regularly named files. str_replace_all works the same way but replaces all matches of the search pattern. # replace all unwanted characters from this hypothetical filename with spaces filename = &quot;sim_param1_0.01_param2_0.05_param3_0.01.ext&quot; str_replace_all(filename, pattern = &quot;(sim_)|_*param\\\\d{1}_|(.ext)&quot;, replacement = &quot; &quot;) ## [1] &quot; 0.01 0.05 0.01 &quot; str_remove is a wrapper around str_replace where the replacement is set to \"\". This is not covered here. Having replaced unwanted characters in the filename with spaces, str_trim offers a way to remove leading and trailing whitespaces. # trim whitespaces from this filename after replacing unwanted text filename = &quot;sim_param1_0.01_param2_0.05_param3_0.01.ext&quot; filename_with_spaces = str_replace_all(filename, pattern = &quot;(sim_)|_*param\\\\d{1}_|(.ext)&quot;, replacement = &quot; &quot;) filename_without_spaces = str_trim(filename_with_spaces) filename_without_spaces ## [1] &quot;0.01 0.05 0.01&quot; # the result can be split on whitespaces to return useful data str_split(filename_without_spaces, &quot; &quot;) ## [[1]] ## [1] &quot;0.01&quot; &quot;0.05&quot; &quot;0.01&quot; 1.2.7 Subsetting within strings When strings are highly regular, useful data can be extracted from a string using str_sub. In the date-time example, the year is always represented by the first four characters. # get the year as characters 1 - 4 str_sub(string = c(&quot;1970-somemonth-01&quot;, &quot;1990-anothermonth-01&quot;, &quot;2010-thismonth-01&quot;), start = 1, end = 4) ## [1] &quot;1970&quot; &quot;1990&quot; &quot;2010&quot; Similarly, it’s possible to extract the last few characters using negative indices. # get the day as characters -2 to -1 str_sub(string = c(&quot;1970-somemonth-01&quot;, &quot;1990-anothermonth-21&quot;, &quot;2010-thismonth-31&quot;), start = -2, end = -1) ## [1] &quot;01&quot; &quot;21&quot; &quot;31&quot; Finally, it’s also possible to replace characters within a string based on the position. This requires using the assignment operator &lt;-. # replace all days in these dates to 01 date_times = c(&quot;1970-somemonth-25&quot;, &quot;1990-anothermonth-21&quot;, &quot;2010-thismonth-31&quot;) # a strictly necessary use of the assignment operator str_sub(date_times, start = -2, end = -1) &lt;- &quot;01&quot; date_times ## [1] &quot;1970-somemonth-01&quot; &quot;1990-anothermonth-01&quot; &quot;2010-thismonth-01&quot; 1.2.8 Padding and truncating strings Strings included in filenames or plots are often of unequal lengths, especially when they represent numbers. str_pad can pad strings with suitable characters to maintain equal length filenames, with which it is easier to work. # pad so all values have three digits str_pad(string = c(&quot;1&quot;, &quot;10&quot;, &quot;100&quot;), width = 3, side = &quot;left&quot;, pad = &quot;0&quot;) ## [1] &quot;001&quot; &quot;010&quot; &quot;100&quot; Strings can also be truncated if they are too long. str_trunc(string = c(&quot;bananas are great and wonderful and more stuff about bananas and it really goes on about bananas&quot;), width = 27, side = &quot;right&quot;, ellipsis = &quot;etc. etc.&quot;) ## [1] &quot;bananas are great etc. etc.&quot; 1.2.9 Stringr aspects not covered here Some stringr functions are not covered here. These include: - str_wrap (of dubious use), - str_interp, str_glue* (better to use glue; see below), - str_sort, str_order (used in sorting a character vector), - str_to_case* (case conversion), and - str_view* (a graphical view of search pattern matches). stringi, of which stringr is a wrapper, offers a lot more flexibility and control. 1.3 String interpolation with glue The idea behind string interpolation is to procedurally generate new complex strings from pre-existing data. glue is as simple as the example shown. # print that each car name is a car model cars = rownames(head(mtcars)) glue(&#39;The {cars} is a car model&#39;) ## The Mazda RX4 is a car model ## The Mazda RX4 Wag is a car model ## The Datsun 710 is a car model ## The Hornet 4 Drive is a car model ## The Hornet Sportabout is a car model ## The Valiant is a car model This creates and prints a vector of car names stating each is a car model. The related glue_data is even more useful in printing from a dataframe. In this example, it can quickly generate command line arguments or filenames. # use dataframes for now parameter_combinations = data.frame(param1 = letters[1:5], param2 = 1:5) # for command line arguments or to start multiple job scripts on the cluster glue_data(parameter_combinations, &#39;simulation-name {param1} {param2}&#39;) ## simulation-name a 1 ## simulation-name b 2 ## simulation-name c 3 ## simulation-name d 4 ## simulation-name e 5 # for filenames glue_data(parameter_combinations, &#39;sim_data_param1_{param1}_param2_{param2}.ext&#39;) ## sim_data_param1_a_param2_1.ext ## sim_data_param1_b_param2_2.ext ## sim_data_param1_c_param2_3.ext ## sim_data_param1_d_param2_4.ext ## sim_data_param1_e_param2_5.ext Finally, the convenient glue_sql and glue_data_sql are used to safely write SQL queries where variables from data are appropriately quoted. This is not covered here, but it is good to know it exists. glue has some more functions — glue_safe, glue_collapse, and glue_col, but these are infrequently used. Their functionality can be found on the glue github page. "],
["working-with-lists-and-iteration.html", "Section 2 Working with lists and iteration 2.1 Basic iteration with map 2.2 More map variants 2.3 Modification in place 2.4 Working with lists", " Section 2 Working with lists and iteration # load the tidyverse library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ── ## ✔ ggplot2 3.3.0 ✔ purrr 0.3.4 ## ✔ tibble 3.0.1 ✔ dplyr 0.8.5 ## ✔ tidyr 1.0.2 ✔ forcats 0.5.0 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::collapse() masks glue::collapse() ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() 2.1 Basic iteration with map Iteration in base R is commonly done with for and while loops. There is no readymade alternative to while loops in the tidyverse. However, the functionality of for loops is spread over the map family of functions. purrr functions are functionals, i.e., functions that take another function as an argument. The closest equivalent in R is the *apply family of functions: apply, lapply, vapply and so on. A good reason to use purrr functions instead of base R functions is their consistent and clear naming, which always indicates how they should be used. This is explained in the examples below. These reasons, as well as how map is different from for and lapply are best explained in the Advanced R book. 2.1.1 map basic use map works on any list-like object, which includes vectors, and always returns a list. map takes two arguments, the object on which to operate, and the function to apply to each element. # get the square root of each integer 1 - 10 some_numbers = 1:10 map(some_numbers, sqrt) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 1.414214 ## ## [[3]] ## [1] 1.732051 ## ## [[4]] ## [1] 2 ## ## [[5]] ## [1] 2.236068 ## ## [[6]] ## [1] 2.44949 ## ## [[7]] ## [1] 2.645751 ## ## [[8]] ## [1] 2.828427 ## ## [[9]] ## [1] 3 ## ## [[10]] ## [1] 3.162278 2.1.2 map variants returning vectors Though map always returns a list, it has variants named map_* where the suffix indicates the return type. map_chr, map_dbl, map_int, and map_lgl return character, double (numeric), integer, and logical vectors. # use map_dbl to get a vector of square roots some_numbers = 1:10 map_dbl(some_numbers, sqrt) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 ## [9] 3.000000 3.162278 # map_chr will convert the output to a character map_chr(some_numbers, sqrt) ## [1] &quot;1.000000&quot; &quot;1.414214&quot; &quot;1.732051&quot; &quot;2.000000&quot; &quot;2.236068&quot; &quot;2.449490&quot; ## [7] &quot;2.645751&quot; &quot;2.828427&quot; &quot;3.000000&quot; &quot;3.162278&quot; # map_int will NOT round the output to an integer # map_lgl returns TRUE/FALSE values some_numbers = c(NA, 1:3, NA, NaN, Inf, -Inf) map_lgl(some_numbers, is.na) ## [1] TRUE FALSE FALSE FALSE TRUE TRUE FALSE FALSE Integrating map and tidyr::nest The example show how each map variant can be used. This integrates tidyr::nest with map, and the two are especially complementary. # nest mtcars into a list of dataframes based on number of cylinders some_data = as_tibble(mtcars, rownames = &quot;car_name&quot;) %&gt;% group_by(cyl) %&gt;% nest() # get the number of rows per dataframe # the mean mileage # and the first car some_data = some_data %&gt;% mutate(n_rows = map_int(data, nrow), mean_mpg = map_dbl(data, ~mean(.$mpg)), first_car = map_chr(data, ~first(.$car_name))) some_data ## # A tibble: 3 x 5 ## # Groups: cyl [3] ## cyl data n_rows mean_mpg first_car ## &lt;dbl&gt; &lt;list&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 6 &lt;tibble [7 × 11]&gt; 7 19.7 Mazda RX4 ## 2 4 &lt;tibble [11 × 11]&gt; 11 26.7 Datsun 710 ## 3 8 &lt;tibble [14 × 11]&gt; 14 15.1 Hornet Sportabout map accepts multiple functions that are applied in sequence to the input list-like object, but this is confusing to the reader and ill advised. 2.1.3 map variants returning dataframes map_df returns data frames, and by default binds dataframes by rows, while map_dfr does this explicitly, and map_dfc does returns a dataframe bound by column. # split mtcars into 3 dataframes, one per cylinder number some_list = split(mtcars, mtcars$cyl) # get the first two rows of each dataframe map_df(some_list, head, n = 2) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## 2 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## 3 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## 4 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## 5 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## 6 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 map accepts arguments to the function being mapped, such as in the example above, where head() accepts the argument n = 2. map_dfr behaves the same as map_df. # the same as above but with a pipe some_list %&gt;% map_dfr(head, n = 2) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## 2 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## 3 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## 4 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## 5 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## 6 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 map_dfc binds the resulting 3 data frames of two rows each by column, and automatically repairs the column names, adding a suffix to each duplicate. some_list %&gt;% map_dfc(head, n = 2) ## mpg cyl disp hp drat wt qsec vs am gear carb mpg1 cyl1 disp1 hp1 drat1 ## 1 22.8 4 108.0 93 3.85 2.32 18.61 1 1 4 1 21 6 160 110 3.9 ## 2 24.4 4 146.7 62 3.69 3.19 20.00 1 0 4 2 21 6 160 110 3.9 ## wt1 qsec1 vs1 am1 gear1 carb1 mpg2 cyl2 disp2 hp2 drat2 wt2 qsec2 vs2 am2 ## 1 2.620 16.46 0 1 4 4 18.7 8 360 175 3.15 3.44 17.02 0 0 ## 2 2.875 17.02 0 1 4 4 14.3 8 360 245 3.21 3.57 15.84 0 0 ## gear2 carb2 ## 1 3 2 ## 2 3 4 2.1.4 Selective mapping map_at and map_if 2.2 More map variants 2.2.1 map2 imap here 2.2.2 pmap 2.2.3 walk walk2 and pwalk 2.3 Modification in place modify 2.4 Working with lists 2.4.1 Filtering lists 2.4.2 Summarising lists 2.4.3 Reduction and accumulation 2.4.4 Miscellaneous operation "]
]
