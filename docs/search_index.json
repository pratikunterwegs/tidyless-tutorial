[
["index.html", "TRES Tidyverse Tutorial Outline", " TRES Tidyverse Tutorial Raphael and Pratik 2020-05-15 Outline This is the readable version of the TRES tidyverse tutorial, with these sections: Reading data and string manipulation with readr, stringr, and glue The new data frames with tibble and wrangling them into shape with tidyr Manipulating data with dplyr Iteration and functional programming with purrr Plotting with ggplot2 "],
["reading-files-and-string-manipulation.html", "Section 1 Reading files and string manipulation 1.1 Section on readr 1.2 String manipulation with stringr", " Section 1 Reading files and string manipulation library(readr) library(stringr) library(glue) 1.1 Section on readr 1.2 String manipulation with stringr stringr functions begin with str_. 1.2.1 Growing strings Concatenate two strings with str_c, and duplicate strings with str_dup. # str_c works like paste(), choose a separator str_c(&quot;this string&quot;, &quot;this other string&quot;, sep = &quot;_&quot;) ## [1] &quot;this string_this other string&quot; # str_dup works like rep str_dup(&quot;this string&quot;, times = 3) ## [1] &quot;this stringthis stringthis string&quot; 1.2.2 Detecting strings Count the frequency of a pattern in a string with str_count. Returns an int. Detect whether a pattern exists in a string with str_detect. Returns a logical and can be used as a predicate. Both are vectorised, i.e, automatically applied to a vector of arguments. # there should be 5 a-s here str_count(string = &quot;ababababa&quot;, pattern = &quot;a&quot;) ## [1] 5 # vectorise over the input string # this should return a vector of length 2, with integers 5 and 3 str_count(string = c(&quot;ababbababa&quot;, &quot;banana&quot;), pattern = &quot;a&quot;) ## [1] 5 3 # vectorise over the pattern to count both a-s and b-s str_count(string = &quot;ababababa&quot;, pattern = c(&quot;a&quot;, &quot;b&quot;)) ## [1] 5 4 Vectorising over both string and pattern works as expected. # vectorise over both string and pattern # counts a-s in first input, and b-s in the second str_count(string = c(&quot;ababababa&quot;, &quot;banana&quot;), pattern = c(&quot;a&quot;, &quot;b&quot;)) ## [1] 5 1 # provide a longer pattern vector to search for both a-s and b-s in both inputs str_count(string = c(&quot;ababababa&quot;, &quot;banana&quot;), pattern = c(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;)) ## [1] 5 1 4 3 # str_detect detects a sequence in a string str_detect(string = &quot;Bananageddon is coming!&quot;, pattern = &quot;na&quot;) ## [1] TRUE # str_detect is also vectorised and returns a two-element logical vector str_detect(string = &quot;Bananageddon is coming!&quot;, pattern = c(&quot;na&quot;, &quot;don&quot;)) ## [1] TRUE TRUE # use any or all to convert a multi-element logical to a single logical # here we ask if either of the patterns is detected any(str_detect(string = &quot;Bananageddon is coming!&quot;, pattern = c(&quot;na&quot;, &quot;don&quot;))) ## [1] TRUE Detect whether a string starts or ends with a pattern. Also vectorised. Both have a negate argument, which returns the negative, i.e., returns FALSE is a pattern is detected. # taken straight from the examples, because they suffice fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;pineapple&quot;) # str_detect looks at the first character str_starts(fruit, &quot;p&quot;) ## [1] FALSE FALSE TRUE TRUE # str_ends looks at the last character str_ends(fruit, &quot;e&quot;) ## [1] TRUE FALSE FALSE TRUE # an example of negate = TRUE str_ends(fruit, &quot;e&quot;, negate = TRUE) ## [1] FALSE TRUE TRUE FALSE 1.2.3 Matching strings str_match returns all positive matches of the patttern in the string. str_match_all(string = &quot;bananaa99 banana90&quot;, pattern = c(&quot;[0-9]&quot;)) ## [[1]] ## [,1] ## [1,] &quot;9&quot; ## [2,] &quot;9&quot; ## [3,] &quot;9&quot; ## [4,] &quot;0&quot; str_extract_all(string = &quot;bananaa99 banana90&quot;, pattern = c(&quot;[0-9]+&quot;)) ## [[1]] ## [1] &quot;99&quot; &quot;90&quot; "],
["iteration-and-functional-programming-with-purrr.html", "Section 2 Iteration and functional programming with purrr 2.1 Iteration with map and variants", " Section 2 Iteration and functional programming with purrr # load the tidyverse library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ── ## ✔ ggplot2 3.3.0 ✔ purrr 0.3.4 ## ✔ tibble 3.0.1 ✔ dplyr 0.8.5 ## ✔ tidyr 1.0.2 ✔ forcats 0.5.0 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::collapse() masks glue::collapse() ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() 2.1 Iteration with map and variants Iteration in base R is commonly done with for and while loops. There is no readymade alternative to while loops in the tidyverse. z However, the functionality of for loops is spread over the map family of functions. map and relatives are functionals, functions which accept other functions as arguments. 2.1.1 map basic use Consider a case in which multiple files must be read in. files_to_read = list.files(&quot;&quot;) "]
]
