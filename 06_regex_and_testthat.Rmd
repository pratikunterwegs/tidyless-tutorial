---
title: Regular expressions and testthat
editor_options:
  chunk_output_type: console
---

# Regular expressions and `testthat`

Richel Bilderbeek

## Introduction

![](data/06_regular_expressions.png)

> 'Regular expressions' from https://xkcd.com/208

### Goal

In this chapter, you will learn:

 * How to express your ideas as a regular expression
 * Verify that you indeed did so

### Why is this important?

Knowing the basics of regular expressions, prevents you having
to hand-craft functions to detect patterns in any text.

Being able to verify your own assumptions allows you to speed
up any development of any code. It is estimated that 80-90%
of all the time, we are debugging our code. Being good at
testing, is the way to become faster.

### Exercise: Spot the pattern

Each line below is or contains a pattern. Observe what your brain does
when interpreting a line. If it thinks: 'Hey, that's a [pattern],
because [regular expression]', you got your answer!

Answer, for each line: (1) what is it? (2) why did you think to?

```
Lithium-ion batteries play a central role in the world of technology.
But would it be safe to simply orbit the planet?
Your Next Samsung Phone May Not Come With a Charger in the Box
The restrictions would end 90 days after Portland's state of emergency order lifts.
Those cities have limits at 15%.
```

### Answers: Spot the pattern

```
Lithium-ion batteries play a central role in the world of technology.
```

This is a sentence, because it ends with a dot.

```
But would it be safe to simply orbit the planet?
```

This is a question, becase it ends with a question mark.

```
Your Next Samsung Phone May Not Come With a Charger in the Box
```

This is a title, because most words start with an uppercase character.

```
The restrictions would end 90 days after Portland's state of emergency order lifts.
```

This is a sentence with a decimal number, because there is a sequence of
characters that consists out of numbers only.

```
Those cities have limits at 15%.
```

This is a sentence with a percentage, because there is a sequence of
characters that consists out of numbers only, with a percentage sign connected
to it.

 * Texts from [https://slashdot.org](https://slashdot.org).

### What are regular expressions?

A regular expression 'is a sequence of characters that define a
search pattern'. Such a pattern may be a zip code, a date,
or any other text of which you can say: 'this is not just text,
it is a [something]'.

For example, take a Dutch zip code: `9747 AG`. Dutch zip
code have four digits, a space and then two uppercase
alphabet characters.

A regex for this is `[:digit:]{4} [:upper:]{2}`.

### Applications

DNA data:

```
>KU215420.1|Felinecoronavirus|Feliscatus|Belgium|2013|Envelope
ATGATGTTTCCTAGGGCATTTACTATCATAGATGACCATGGTATGGTTGTTAGTGTCTTC
>KP143511.1|Felinecoronavirus|Feliscatus|UnitedKingdom|2013|Envelope
ATGATGTTTCCTAGGGCATTTACTATCATAGACGACCATGGTATGGTTGTTAGTGTCTTC
```

Protein data:

```
>sp|P0DTC2|SPIKE_SARS2 Spike glycoprotein OS=Severe acute respiratory syndrome coronavirus 2 OX=2697049 GN=S PE=1 SV=1
MFVFLVLLPLVSSQCVNLTTRTQLPPAYTNSFTRGVYYPDKVFRSSVLHSTQDLFLPFFS
>sp|P0DTC5|VME1_SARS2 Membrane protein OS=Severe acute respiratory syndrome coronavirus 2 OX=2697049 PE=3 SV=1
MADSNGTITVEELKKLLEQWNLVIGFLFLTWICLLQFAYANRNRFLYIIKLIFLWLLWPV
```

Most messy Excel sheets :-)

### Multiple in R

![](data/06_stringr.png)

> The 'stringr' logo. 'stringr' is part of the Tidyverse

R functions to work with regular expressions:

 * `stringr::string_`
 * `egrep`
 * `gsub`

```{r}
library(stringr)
```

### Dangers of regexes

![](data/06_perl_problems.png)

> 'Perl problems', from https://xkcd.com/1171/

Regexes have different dialects, such as POSIX and perl.
Within R, there are the base R dialect and the Tidyverse dialect.

> I define UNIX as 30 definitions of regular expressions living under one roof.
>
> Donald Knuth. Digital Typography, ch. 33, p. 649 (1999)

We'll have to test!

## Testing

![](data/06_george_dinwiddie.jpg)

> From George Dinwiddie's blog, http://blog.gdinwiddie.com/2012/12/26/tdd-hat/

### Why test?

> Testers donâ€™t like to break things;
> they like to dispel the illusion that things work.
>
> Kaner, Bach, Pettichord

 * To be sure your code is correct
 * Spend less time fixing bugs
 * Unit of communication
 * Clean software interface

### Our first test

The `testthat` package is the Tidyverse package to write tests.

```{r}
library(testthat)
```

All test functions start with `expect_`, for example:

```{r}
expect_true(1 + 1 == 2)
expect_false("cat" == "dog")
expect_equal(1 + 1, 2)
```

## Detect a full match

Here, we will detect simple patterns using `str_which`.

Tip: run `?str_which` for its documentation.

![](data/06_detect.png)

> From 'Work with Strings Cheatsheet', https://rstudio.com/resources/cheatsheets


### `str_which` demo

```{r}
fruit <- c("apple", "banana", "pinapple")

expect_equal(
  str_which(fruit, "banana"),
  2
)

expect_equal(
  str_which(fruit, "apple"),
  c(1, 3)
)

expect_equal(
  str_which(fruit, "submarine"),
  integer(0)
)
```

### Example exercise: `is_a_one`

Write a function called `is_a_one` that detects if a string is one one,
using `str_subset`.

Use the anchors as shown on the cheatsheet to specify that
the complete string, from begin to the end, must consist out of characters

![](data/06_anchors.png)

> From 'Work with Strings Cheatsheet', https://rstudio.com/resources/cheatsheets

These tests must pass:

```
expect_true(is_a_one("1"))
expect_false(is_a_one("X"))
expect_false(is_a_one("11"))
expect_false(is_a_one(c("1", "1")))
expect_false(is_a_one(integer(0)))
expect_false(is_a_one(NULL))
expect_false(is_a_one(NA))
expect_false(is_a_one(Inf))
```

#### Answer `is_a_one`

```{r}
is_a_one <- function(text) {
  length(stringr::str_which(text, "^1$")) == 1
}
```

Note that you may have had a differet regex.
No worries: if all tests pass, you did a great job!

```{r}
expect_true(is_a_one("1"))
expect_false(is_a_one("X"))
expect_false(is_a_one("11"))
expect_false(is_a_one(c("1", "1")))
expect_false(is_a_one(integer(0)))
expect_false(is_a_one(NULL))
expect_false(is_a_one(NA))
expect_false(is_a_one(Inf))
```

### Exercise: `is_a_digit`

Write a function called `is_a_digit` that detects if a string is one digit.

Use the regex pattern as shown on the cheatsheet to specify a digit:

![](data/06_character_sets.png)

> From 'Work with Strings Cheatsheet', https://rstudio.com/resources/cheatsheets

These tests must pass:

```
expect_true(is_a_digit("0"))
expect_true(is_a_digit("1"))
expect_false(is_a_digit(""))
expect_false(is_a_digit("X"))
expect_false(is_a_digit(c("1", "2")))
expect_false(is_a_digit(character(0)))
expect_false(is_a_digit(NULL))
expect_false(is_a_digit(NA))
expect_false(is_a_digit(Inf))
```

#### Answer: `is_a_digit`

```{r}
is_a_digit <- function(text) {
  length(stringr::str_which(text, "^[:digit:]$")) == 1
}
```

```{r}
expect_true(is_a_digit("0"))
expect_true(is_a_digit("1"))
expect_false(is_a_digit(""))
expect_false(is_a_digit("12"))
expect_false(is_a_digit("X"))
expect_false(is_a_digit(c("1", "2")))
expect_false(is_a_digit(character(0)))
expect_false(is_a_digit(NULL))
expect_false(is_a_digit(NA))
expect_false(is_a_digit(Inf))
```

### Exercise: `is_a_word`

Write a function called `is_a_word` that detects if a string is a word.

To simplify now, a word is defined as:

 * Having one or more lowercase characters
 * Having no dashes, nor numbers

Use the quantifiers as shown on the cheatsheet to specify that one needs
one or more characters:

![](data/06_quantifiers.png)

> From 'Work with Strings Cheatsheet', https://rstudio.com/resources/cheatsheets


These tests must pass:

```
expect_true(is_a_word("a"))
expect_true(is_a_word("an"))
expect_true(is_a_word("apple"))
expect_false(is_a_word("X"))
expect_false(is_a_word("XX"))
expect_false(is_a_word("Hi"))
expect_false(is_a_word("hI"))
expect_false(is_a_word("hoWdy"))
expect_false(is_a_word(c("an", "apple")))
expect_false(is_a_word(character(0)))
expect_false(is_a_word(NULL))
expect_false(is_a_word(NA))
expect_false(is_a_word(Inf))
```

#### Answer: `is_a_word`

```{r}
is_a_word <- function(text) {
  length(stringr::str_which(text, "^[:lower:]+$")) == 1
}
```

```{r}
expect_true(is_a_word("a"))
expect_true(is_a_word("an"))
expect_true(is_a_word("apple"))
expect_false(is_a_word("X"))
expect_false(is_a_word("XX"))
expect_false(is_a_word("Hi"))
expect_false(is_a_word("hI"))
expect_false(is_a_word("hoWdy"))
expect_false(is_a_word(c("an", "apple")))
expect_false(is_a_word(character(0)))
expect_false(is_a_word(NULL))
expect_false(is_a_word(NA))
expect_false(is_a_word(Inf))
```

### Exercise: `is_dna_sequence`

Write a function called `is_dna_sequence` that detects if a string is
a DNA sequence.

To simplify now, a DNA sequence is defined as:

 * There are four characters, one per nucleotides
 * These characters are uppercase (A, C, G and T)

Use the alternates as shown on the cheatsheet to specify that
each character must be one of the four nucleotides:

![](data/06_alternates.png)

> From 'Work with Strings Cheatsheet', https://rstudio.com/resources/cheatsheets

These tests must pass:

```
expect_true(is_dna_sequence("A"))
expect_true(is_dna_sequence("AC"))
expect_true(is_dna_sequence("ACG"))
expect_true(is_dna_sequence("ACGT"))
expect_false(is_dna_sequence("a"))
expect_false(is_dna_sequence("Ax"))
expect_false(is_dna_sequence("xA"))
expect_false(is_dna_sequence("AxA"))
expect_false(is_dna_sequence(c("A", "CGT")))
expect_false(is_dna_sequence(character(0)))
expect_false(is_dna_sequence(NULL))
expect_false(is_dna_sequence(NA))
expect_false(is_dna_sequence(Inf))
```

#### Answer: `is_dna_sequence`

```{r}
is_dna_sequence <- function(text) {
  length(stringr::str_which(text, "^[ACGT]+$")) == 1
}
```

```{r}
expect_true(is_dna_sequence("A"))
expect_true(is_dna_sequence("AC"))
expect_true(is_dna_sequence("ACG"))
expect_true(is_dna_sequence("ACGT"))
expect_false(is_dna_sequence("a"))
expect_false(is_dna_sequence("Ax"))
expect_false(is_dna_sequence("xA"))
expect_false(is_dna_sequence("AxA"))
expect_false(is_dna_sequence(c("A", "CGT")))
expect_false(is_dna_sequence(character(0)))
expect_false(is_dna_sequence(NULL))
expect_false(is_dna_sequence(NA))
expect_false(is_dna_sequence(Inf))
```

## Extract a pattern

Here, we will extract a pattern using `str_match`.

Tip: run `?str_match` for its documentation.

![](data/06_subset.png)

> From 'Work with Strings Cheatsheet', https://rstudio.com/resources/cheatsheets

### Context

Here we will work on a DNA sequence:

```{r}
text <- readr::read_lines("data/virus.fas")
head(text, n = 10)
```

The data encoded in this text:

```
>[DNA sequence number]|[virus name]|[host species name]|[country of host]|[year]|[protein name]"
[DNA sequence]
```

### `str_match`

`str_match` returns:

 * a matrix
 * a row per line of text, containing the match or an NA
 * a column per submatch (see later)

For example, using a 'everything' pattern, we get:

```{r str_match_pokemon}
matches <- stringr::str_match(text, ".*")
expect_is(matches, "matrix")
expect_equal(nrow(matches), length(text))
expect_equal(ncol(matches), 1)
head(matches)
```

![](data/06_catch_em_all.jpg)

Using a pattern that is specific for the DNA sequence descriptors,
we get NAs:

```{r str_match_sequence_descriptor_lines}
matches <- stringr::str_match(text, ">.*")
expect_is(matches, "matrix")
expect_equal(nrow(matches), length(text))
expect_equal(ncol(matches), 1)
head(matches, n = 8)
```

Using round brackets, the matrix gives one extra column per sub-match.
Here, we select for all info after the `>`:

```{r str_match_sequence_descriptor_as_column}
matches <- stringr::str_match(text, ">(.*)")
expect_is(matches, "matrix")
expect_equal(nrow(matches), length(text))
expect_equal(ncol(matches), 2)
head(matches, n = 8)
```

Select the second column:

```{r str_match_select_col_with_sequence_descriptor}
matches <- matches[, 2]
expect_is(matches, "character")
expect_equal(length(matches), 180)
head(matches, n = 8)
```

Get rid of the `NAs` using `purrr`:

```{r str_match_remove_na}
matches <- as.character(na.omit(matches))
expect_is(matches, "character")
expect_equal(length(matches), 30)
head(matches)
```

All of this in one go:

```{r str_match_all_at_once}
matches <- as.character(
  na.omit(
    stringr::str_match(text, ">(.*)")[, 2]
  )
)
expect_equal(length(matches), 30)
head(matches)
```

### Example exercise: `extract_dna_sequence_numbers`

Extract the DNA sequence numbers.

Hint:

 * it is the text between `>` and `|Felinecoronavirus`.
 * Use `\\|` in your regex to indicate you want the pipe character (
   as `a|b` is the regex for 'a or b')

These tests must pass:

```
expect_equal(30, length(extract_dna_sequence_numbers(text)))
expect_equal("KX722530.1", extract_dna_sequence_numbers(text)[1])
expect_equal("KP143511.1", extract_dna_sequence_numbers(text)[30])
```

### Answer: `extract_dna_sequence_numbers`

```{r}
extract_dna_sequence_numbers <- function(text) {
  purrr::discard(
    stringr::str_match(text, ">(.*)\\|Felinecoronavirus.*")[, 2],
    is.na
  )
}
```

```{r}
expect_equal(30, length(extract_dna_sequence_numbers(text)))
expect_equal("KX722530.1", extract_dna_sequence_numbers(text)[1])
expect_equal("KP143511.1", extract_dna_sequence_numbers(text)[30])
```

The regex `">(.*)\\|.*"` would not work, because the asterisk is *greedy*.

### Exercise: `extract_year`

Extract the year the DNA sequence has been obtained.
Convert the text to a number.

Hint: the year is always 4 consecutive numbers,
from 1993 to (and including) 2016.

These tests must pass:

```
expect_equal(30, length(extract_year(text)))
expect_equal(2015, extract_year(text)[1])
expect_equal(2013, extract_year(text)[30])
```

### Answer: `extract_year`

```{r}
extract_year <- function(text) {
  as.numeric(
    purrr::discard(
      stringr::str_match(text, ".*([:digit:]{4}).*")[, 2],
      is.na
    )
  )
}
```

```{r}
expect_equal(30, length(extract_year(text)))
expect_equal(2015, extract_year(text)[1])
expect_equal(2013, extract_year(text)[30])
```

Here, the simple regex worked, *because* the asterisk is greedy.

## Multiple matches: `str_match` again

`str_match` allows to extract multiple matches at once:

```{r}
text <- c(
  "2020/03/14",
  "not a date",
  "2020/07/22"
)
stringr::str_match(
  text, "([:digit:]{4})/([:digit:]{2})/([:digit:]{2})"
)
```

### Context

Here we will work on a proteome:

```{r}
text <- readr::read_lines("data/UP000464024.fasta")
head(text, n = 7)
```

The data encoded in this text:

```
>sp|[Sequence ID]|[Protein ID] [Protein description] OS=[Virus name] OX=[OX] GN=[GN] PE=[PE] SV=[SV]
[Peptide sequence]
```

We will only look at `[Sequence ID]` and `[Protein ID]`.

### Exercise: `extract_prot_and_seq_ids`

Extract all proteins' ID and sequence ID, in a tibble.

```{r}
library(tibble)
```

These tests must pass:

```
t <- extract_prot_and_seq_ids(text)
expect_true(is_tibble(t))
expect_equal(13, nrow(t))
expect_equal(2, ncol(t))
expect_equal(colnames(t), c("seq_id", "prot_id"))
expect_equal(t$seq_id[1], "P0DTC7")
expect_equal(t$prot_id[1], "NS7A_SARS2")
expect_equal(t$seq_id[13], "P0DTC5")
expect_equal(t$prot_id[13], "VME1_SARS2")
```

### Answer: `extract_prot_and_seq_ids`

```{r}
extract_prot_and_seq_ids <- function(text) {
  matrix <- na.omit(
    stringr::str_match(text,
      ">sp\\|([:graph:]+)\\|([:graph:]+) ")[, c(2, 3)]
  )
  colnames(matrix) <- c("seq_id", "prot_id")
  tibble::as_tibble(matrix)
}
```

```{r}
t <- extract_prot_and_seq_ids(text)
expect_true(is_tibble(t))
expect_equal(13, nrow(t))
expect_equal(2, ncol(t))
expect_equal(colnames(t), c("seq_id", "prot_id"))
expect_equal(t$seq_id[1], "P0DTC7")
expect_equal(t$prot_id[1], "NS7A_SARS2")
expect_equal(t$seq_id[13], "P0DTC5")
expect_equal(t$prot_id[13], "VME1_SARS2")
```


## Other functions

### Mutate

![](data/06_mutate.png)

> From 'Work with Strings Cheatsheet', https://rstudio.com/resources/cheatsheets

```{r}
s <- "UnitedKingdom"
t <- stringr::str_replace(
  s,
  "([:upper:][:lower:]+)([:upper:][:lower:]+)",
  "\\1 \\2"
)
expect_equal("United Kingdom", t)
```

### `testthat::expect_match`

You may want to test if a function's output matches
a pattern:

```{r}
#' Get the version, for example '1.0'
get_version <- function() {
  sample(c("1.0", "1.1"), size = 1)
}
```

Using `testthat::expect_match` gives an unexpected result:

```{r error=TRUE}
expect_match(
  get_version(),
  "1\\.[:digit:]"
)
```

Take a look at `?testthat::expect_match`:

> Details
>
> expect_match() is a wrapper around grepl().
> See its documentation for more detail about the individual arguments.

Use the base R regex dialect:

```
expect_match(
  get_version(),
  "1\\.[[:digit:]]"
)
```

## Bigger picture

### Develop in packages

 * Also when 'just' doing data analysis

## Regex usage beyond R is common

Command-line tools with regular expressions:

 * `grep`, `egrep`
 * `sed`
 * `dir`/`ls`

### Don't overdo it

![](data/06_regex_golf.png)

> 'Regex Golf', from https://xkcd.com/1313/

Regex golf is a challenge to create the shortest regexes possible.

## Resources

 * [RStudio cheatsheets](https://rstudio.com/resources/cheatsheets/),
   including the 'Work with Strings Cheatsheet'
