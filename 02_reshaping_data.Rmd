---
editor_options:
  chunk_output_type: console
---

# Reshaping data.tables

![](wip.png)


```{r}
library(data.table)
```

The equivalent chapter in the TRES Tidyverse Tutorial has some explanation of what 'tidy' data is, but we'll leave the semantics aside and get to the code.

## `data.table`: A `data.frame` extension

The `data.table` (from here on simply data.table) is a development of the `data.frame`, which is faster and better in two specific ways.

1. Data.tables point to a memory location, so they don't deal with objects 'in memory'. This (usually) means no `R` crashes because you've run out of RAM.

2. Data.tables allow _modifying by reference_, and adding new variables added to a data table in the form `dt$new_var <- c(...)` does not result in data copying, making the operation more memory efficient, and faster.

### Creating a data.table

```{r}
# Make a data frame
data.frame(who = c("Pratik", "Theo", "Raph"), chapt = c("1, 4", "3", "2, 5"))

# Or an equivalent data.table
data.table(who = c("Pratik", "Theo", "Raph"), chapt = c("1, 4", "3", "2, 5"))
```

The conversion of statistical ouput to a data.table is as easy as using tibbles.

```{r}
# Perform a PCA on mtcars
pca_scores <- prcomp(mtcars)$x
head(pca_scores) # looks like a data frame or a tibble...
class(pca_scores) # but is actually a matrix

# Convert to tibble
as.data.table(pca_scores, keep.rownames = TRUE)
```

The important thing to remember when using data.tables is that you need to keep track of which objects are data.tables, and which are data.frames. The two can be interconverted using the _modify in place_ functions `setDT` to convert from data.frame to data.table, and `setDF` for the opposite conversion.

### Modifying in place

Many `data.table` functions modify in place, as with `setDT` above. These change something about the `data.table` without the need for an assignment operator, and can be identified using the `set*` prefix. More examples will be encountered later.

### All-in-one functionality

Data.tables and `data.table` (the package) roll a great deal of the tidyverse's functionality into a single package. Specifically, `data.table` contains its own implementations of most aspects of `tibble`, `dplyr`, and `tidyr`. If you use the pipe operator `%>%` from the `magrittr` package, this can also be replaced in operation chaining exercises by `data.table`'s inbuilt chaining functionality.

### What cannot be replaced {-}

`data.table` has its own internal logic, which has a bit of a learning curve, but not more so than the more complex parts of the tidyverse. Some operations from `tidyr` such as `unnest` are truly difficult to reproduce succinctly using only base R and `data.table`. Yet, they can be replicated with some work. It is up to the user to determine whether one less dependency balances the need for relatively complex code.

This is important because a `matrix` can contain only one type of values (e.g. only `numeric` or `character`), while `data.tables` (and `data.frame`) allow you to have columns of different types.

## Wide to long conversion

Converting data.tables from wide to long format (we shall eschew 'tidy' and 'messy') is done using the `melt` function. Once upon a time, the `reshape` and `reshape2` packages provided this function, and may still do so. `data.table` provides its own implementation.

Here we _melt_ the finch morphometry data simulated in the tidyverse tutorial from wide to long.

```{r}
# We first simulate random data
beak_lengths <- rnorm(100, mean = 5, sd = 0.1)
beak_widths <- rnorm(100, mean = 2, sd = 0.1)
body_weights <- rgamma(100, shape = 10, rate = 1)
islands <- rep(c("Isabela", "Santa Cruz"), each = 50)

# Assemble into a data.table
data <- data.table(
  id = 1:100,
  body_weight = body_weights,
  beak_length = beak_lengths,
  beak_width = beak_widths,
  island = islands
)

# Snapshot
data
```

This is converted to long format using `melt`, with the _identity_ variables being set as individual id (`id`) and island name (`island`).

```{r}
data <- melt(
  data,
  id.vars = c("id", "island")
)

data
```

### Tables: Wide to long

Contingency tables (e.g. how many observations we have for each morphometric and each island) are also easy to handle. First, `table` (from base R) provides the initial table, which is in wide format.

```{r}
# Make a contingency table
ctg <- with(data, table(island, variable))
ctg
```

`as.data.table` converts wide to long automatically.

```{r}
# Contingency table is pivoted to the long-format automatically
as.data.table(ctg)
```

### Long to wide conversion

Data may be required in wide format from time to time. Again, this used to be the _forte_ of the `reshape*` packages, and `data.table` provides its own implementation of the `dcast` function, with which data can be 'cast' from wide to long.

FYI: The analogy is from working with metals, which are melted from billets, and then cast into shape.

`dcast` works a bit differently from other functions, and takes

- a `data.table` or `data.frame`,  
- a formula where the left hand side is made up of the id variables, while the right hand side is the measure variables, and 
- the value variable specified using `value.var`.

In the example, we recover the original wide data that we simulated and then melted wide to long.

```{r}
dcast(data,
      id + island ~ variable, value.var = "value")
```

### Long to wide conversion with aggregation

`dcast` also allows aggregation when there is more than one value per combination of LHS and RHS. In fact, a list of aggregation functions can be specified. Here we pass a list containing `mean` and `sd` functions to obtain the mean and standard deviation of each morphometric measure per island.

```{r}
dcast(data,
      island ~ variable, value.var = "value",
      fun.aggregate = list(mean, sd))
```

### Handling missing values

Missing values can be omitted or replaced using `data.table` implementations of `na.omit` and specific replacement functions.

In the example, we first add some `NA`s.

```{r}
# We replace 100 random observations by NAs
ii <- sample(nrow(data), 100)
data$value[ii] <- NA
data
```

Remove rows that have missing values using `na.omit`.

```{r}
na.omit(data, "value")
```

The `NA`s can also be replaced with some user-defined value using the function `setnafill`.
`setnafill` modifies in place.

```{r}
setnafill(data, 
       cols = "value",
       type = "const", fill = -999)
```

Reminder: Functions starting with `set*` modify the relevant columns in place. In the example above, the `value` column has had `NA`s replaced with `-999` *without being assigned* using the assignment operator.

We could also replace NAs with the most recent non-NA values.

```{r}
ii <- sample(nrow(data), 100)
data$value[ii] <- NA
data

# use locf
setnafill(data, 
       cols = "value",
       type = "locf")

# examine data
data
```

### Assignment in a data table {-}

Assigning a column in a `data.table` can also be done in place, using the `:=` operator in combination with square brackets `[]` and a comma `,`.

A pseudo-code explanation is:

`DT[, new_column := function(old_column <OR> other)]`

For example, `NA`'s can be replaced in a data.table using the `:=` operator and the `nafill` function.
`nafill` is another form of `setnafill` that returns a filled vector, rather than filling `NA`s a data.table in place.

```{r}
data[, value := nafill(value, "locf")]
```

### Splitting and combining columns

`data.table` does not provide a function similar to `tidyr`'s `unite`. This is an operation that can nonetheless be readily replicated using existing data.table functionality and base R functions.

In the example, we make new columns for the date of each observation.

```{r}
# Sample random dates for each observation
data$day <- sample(30, nrow(data), replace = TRUE)
data$month <- sample(12, nrow(data), replace = TRUE)
data$year <- sample(2019:2020, nrow(data), replace = TRUE)
data
```

The `day`, `month` and `year` columns can be combined into a single `date` column, with a dash as a separator, using `base::paste` or `base::sprintf`.

```{r}
# using paste
data[, date := paste(day, month, year, sep = "-")]

# using sprintf
data[, data_sprintf := sprintf("%i-%i-%i", day, month, year)]
```

Splitting a column is a equally easy using the `data.table::tstrsplit` function, which transposes the results of `strsplit`. `strsplit` from base R is a function that splits a string on a pattern, in the following case on the dash `-`. `tstrsplit` takes these pieces and converts them into list-like objects, which can be assigned to a data.table's columns.

```{r}
# using tstrsplit
data[, c("day_new", "month_new", "year_new") := tstrsplit(date, split = "-")]
```

Note the type conversion here.

### Assigning multiple variables at once

Note also how more than one variable can be assigned at once in the example above.
That is only one way of doing it, and two others must be mentioned.

#### Assigning the same value to two variables

Two variables can be assigned the same value at once. Here, both new variables have the same value drawn from a uniform distribution.

```{r}
data[, c("new_var_1", "new_var_2") := stats::runif(nrow(data))]
```

Two variables can also be assigned distinct values, here again randomly drawn.

```{r}
data[, `:=`(new_var_3 = stats::runif(nrow(data)),
            new_var_4 = stats::runif(nrow(data)))]
```

In this case, the `:=` operator is wrapped in backticks, and the new variables are assigned inside round brackets.

### Expanding tables using combinations

Generating a data.table with all possible combinations of two or more vectors is very easy using the `CJ` command (for cross-join).

In the example all combinations of island and year are returned.

```{r}
CJ(
  island = c("Isabela", "Santa Cruz"),
  year = c("2019", "2020")
)
```

However, in the sampling scheme of the example, some `sites` occur only on one island and not on the other.

```{r}
# assign sites A and B to Isabella
# and C and D to Santa Cruz
data[, site := unlist(lapply(data$island, 
                             function(z) {
                               ifelse(z == "Isabela",
                                      sample(LETTERS[1:2]),
                                      sample(LETTERS[3:4]))
                               })
                      )]
```

It is now necessary to nest site within island when crossing all variables. This is achieved in `tidyr` using the function `nesting`, but there is no equivalent in `data.table`. Yet, there is a solution: it is possible to figure out which combinations exist in the data using the `duplicated` function.

`duplicated` returns a `logical` vector, which can be used to filter the data.table.

```{r}
# get a logical vector
!duplicated(dt_new[, .(island, site, year)

# use it to filter the data.table
dt_new[!duplicated(dt_new[, .(island, site, year)]), # check for dups
       .(island, site, year)] # select column in the data.table
```

### Making list columns

`data.table` supports nested list columns, where the contents of a cell are not atomic (integers, numerics, characters etc.), but more complex objects such as vectors or data.tables themselves.

![](wip.png)
