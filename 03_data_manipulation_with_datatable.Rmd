---
editor_options:
  chunk_output_type: console
---

# Data manipulation with `data.table`

```{r load_lib}
library(data.table)
```

## Introduction

This tutorial uses mammal trait data from the [Phylacine](https://megapast2future.github.io/PHYLACINE_1.2/) database, which must first be read in.

```{r read_data, message=FALSE}
data <- fread("data/phylacine_traits.csv")
data
```

## Working with existing variables

### Renaming variables

Changing names is straightforward with `setnames`. This modifies the data.table in place. Columns need to be referred to as strings.

```{r rename}
# data.table setnames does not require assignment
setnames(data, old = "Binomial.1.2", new = "binomial")
```

If all the columns are being renamed, the `old =` and `new =` arguments can be dropped, and a single string for the new names is sufficient.

```{r rename3, echo=FALSE}
# get new names
new_names <- stringi::stri_replace_all_fixed(str = colnames(data),
                                       ".", "_")
new_names <- stringi::stri_replace_all_fixed(new_names, "_1_2", "")
new_names <- stringi::stri_trans_tolower(new_names)

# set new names
setnames(
  x = data,
  new_names
)

# check colnames
colnames(data)
```

### Three ways of pulling variables

Columns can be pulled from a data.table or data.frame by name using the `[[` operator.

*NB*: Pulling a data.table in this way returns a one-column data.table, NOT a vector. Convert the data.table to a vector if that is what you require.
On the other hand, pulling a column in this way from a data.frame returns a vector. The difference is important to keep in mind.

```{r}
# returns a single column data.table
data[, "binomial"]

# returns a vector
head(
  data[["binomial"]]
)

# returns a vector
head(
  data$binomial
)
# returns a vector
head(
  setDF(data)[, "binomial"] # note the changed class
)

# reset to data.table
setDT(data)
```

Remember that in the lines above the `setDF` command which converts the data.table into a regular data.frame. This happens in-place, i.e, the result does not need to be assigned to an object.
The `setDT` function is the opposite, converting a data.frame to a data.table.

### Selecting multiple variables

Selecting variables is done by passing a list-like object to the data.table.
Columns can be renamed while selecting by passing a named list.

```{r select}
# select columns using a character vector
data[, c("binomial", "order", "family")]

# select using non-standard evaluation
data[, .(binomial, order, family)]

# select using a list
data[, list(binomial, order)]

# rename while selecting by passing a named list
data[, list(species = binomial, species_order = order)]
```

### Removing variables

It is not really possible to remove columns from a data.table by appending a `-` sign; instead the variables have to be set to `NULL`, which is the same as it would be for a data.frame. The example below shows how.
Recall the _assign in place_ operator `:=` which is used here to remove a column.

```{r exclude}
# we remove one variable
data[, diet_source := NULL]

colnames(data)
```

Multiple variables can be removed using the general form of assigning variables.
The example below shows how, but is not run.

```{r eval=FALSE}
data[, `:=` (order = NULL, family = NULL)]
```

### Select variables by pattern

Selecting variables sharing parts of their names is relatively easy using the `stringi` package. The trick is to detect a particular pattern in the column names, and to keep only those columns which contain the pattern. This is a bit more involved than `dplyr::select`, but think of the package dependency avoided.

```{r select_help}
# select diet information by detecting a pattern
names_to_select <- stringi::stri_subset(colnames(data), fixed ="diet")
data[, ..names_to_select]
```

## Working with observations

### Ordering rows by value

`setorder` sorts rows in the data by **ascending** value for a given variable.
Use the argument `order = 1 OR -1` to sort by ascending or descending values (with ascending as default).

`setorder` and the related `setorderv` operate _in place_, and are thus memory efficient. It also means that you need to be careful when 'just testing' something out --- the order is changed when you use the command!. Moreover, the order of other pointers to the data is also changed, unless they have a distinct memory location.

The difference between `setorder` and `setorderv` is that the former uses non-standard evaluation and accepts unquoted variable names, while the latter accepts quoted variable names and is more useful when passing the column to order by as a function argument.

```{r}
# mammals ordered by mass
setorder(data, mass_g)[, c("binomial", "mass_g")]

# Largest mammals first
setorderv(data, "mass_g", order = -1)[, c("binomial", "mass_g")]

# sorting by multiple variables
setorder(data, mass_g, diet_plant)[, c("binomial", "mass_g", "diet_plant")]
```

### Subset rows by position

Subsetting by rows works the same as with a regular data frame or a matrix. Simply pass the row numbers to the LHS of the comma within the square brackets.

```{r}
# here we sample five rows of the columns species and family
data[sample(nrow(data), 5), c("binomial", "family")]
```

### Filtering a data.table

Data.tables have no inbuilt filter function, but are filtered by passing either a list-like of rows to be retained (or discarded) or a logical vector of whether corresponding rows should be retained.

```{r megafauna}
# megafauna with the condition mass > 100 g
data[mass_g > 1e7, c("binomial", "mass_g")]

# non-extinct megafauna
data[mass_g > 1e5 & iucn_status != "EP", c("binomial", "mass_g")]
```

Here we determine that all flying mammals are indeed bats.

```{r no_bats}
# flying mammals that are not bats
data[aerial & order != "Chiroptera", ]
```

Further that humans are not included in the dataset.

```{r human_after_all}
data[binomial == "Homo sapiens", ]
```

`NA`s can be filtered out this way.

```{r filter_na}
head(
  data[!is.na(mass_comparison), mass_comparison]
)
```

`data.table` provides %between% and `between()`, which return a logical for whether the value is between the limits or not.

```{r between}
between(1:5, 2, 4)

# fitler for mesofauna
data[between(mass_g, 1e3, 1e5), c("binomial", "mass_g")]
```

### Summarising variables

To get summary values within groups, the general syntax for a data.table is shown below with an example.

**General syntax**

`dt[, .(summary_var = function(existing_var)), by = .(grouping_var)]`

When no grouping variables are supplied, values are summarised over the entire data.table.

```{r summarise}
data[, .(nb_species = .N,
         nb_terrestrial = sum(terrestrial),
         nb_marine = sum(marine),
         nb_freshwater = sum(freshwater),
         nb_aerial = sum(aerial),
         mean_mass_g = mean(mass_g))]
```

### Summarising within groups

Summarising within groups is very easily done by passing one or more column names to the `by = ` argument.

```{r summarise_order}
# get a species count and mean mass by order
data[, .(n_species = .N,
         mean_mass_g = mean(mass_g)),
     by = .(order)]

# passing a list is equivalent to using the .
# renaming on the fly is supported
data[, list(n_species = .N,
         mean_mass_g = mean(mass_g)),
     by = list(mammal_order = order)]
```

Observations can be grouped by multiple variables, which will output a summary for every unique combination of grouping variables.

```{r multiple_groups}
# group by order and family
data[, list(n_species = .N,
            mean_mass_g = mean(mass_g)),
     by = list(mammal_order = order,
               mammal_family = family)]
```

Operation chaining is easily done, but never recommended. This may look complicated, and it is hard to follow for other users not familiar with the syntax.

```{r iucn_prop}
# operation chaining is possible but not recommended
head(                                             # showing only the top rows
  setorder(                                       # arranging by order
    data[, list(n_order_iucn = .N),               # counting order-iucnn sums
         by = list(order, iucn_status)
         ][, n_order := sum(n_order_iucn),        # counting order wise species
           by = order
           ][, p_iucn := n_order_iucn / n_order], # get proportions
    order
  )
)
```

## Working with multiple tables

### Binding tables

`data.table` provides the `rbindlist` function to bind data.tables row or column wise.
Here, the echidna and porpoise data are extracted and bound together by row. The `rbindlist` function needs its output to be assigned, and does not modify in place. The names of the list elements being bound can be converted into a new column whose name is specified by `idcol`.

```{r id_bind}
# get porpoises
porpoises <- data[family == "Phocoenidae", list(binomial, iucn_status)]
echidnas <- data[family == "Tachyglossidae", list(binomial, iucn_status)]

# bind into a single data.table
rbindlist(l = list(porpoises = porpoises, 
                   echidnas = echidnas),
          idcol = "kind")
```

### Merging data.tables

Separate data.tables may contain variables which hold information about the same unique unit of observation, for example, a species. In the example below, the data is split into habitat and diet data, recombined by species. This can be merged into a single data.table using the `merge` function. `merge` will attempt to look for common columns between the input data.tables, but these can also be specified manually.

```{r split_phylacine}
# get species and diet data
cols_wanted <- c("binomial",
                 stringi::stri_subset(colnames(data), regex = "(diet)(?!.[source|method])"))
# get diet
diet <- data[seq(5), ..cols_wanted]

# get family and species
family <- data[seq(3, 8), c("binomial", "family")]
```

The two datasets each contain 5 species, the first three are shared, and the
two last differ between the two.

```{r intersect}
intersect(diet$binomial, family$binomial)
setdiff(diet$binomial, family$binomial)
```

The default merge is an inner join, i.e, only rows in `x` with matching values in the key (i.e, common) columns in `y` are retained.

```{r inner_join}
merge.data.table(x = diet, y = family)
```

The columns on which to join can be specified manually as `by`.

```{r}
merge.data.table(x = diet, y = family, by = "binomial")
```

A left join (all rows in `x` are kept) can be done setting `all.x = TRUE`. Note the missing `family` for the first two observations.

```{r}
merge.data.table(diet, family, all.x = TRUE)
```

A right join (all rows in `y`) and a full join (all rows in `x` and `y`) are also intuitive.

```{r}
# a right join sets all.y = TRUE
merge.data.table(diet, family, all.y = TRUE)

# a full join sets all.x and all.y to TRUE
# all = TRUE is a shorter form for that
merge.data.table(diet, family, all = TRUE)
```

An anti join can be achieved using the chained join, but negating `y` using the `!` operator.
The general form is `x[!y, on = "key_variable]`.

```{r}
# use the negate sign !
diet[!family, on = "binomial"]
```

This syntax is different from those seen before using `merge`, and is a more compact form of `merge`, that can also be used for other joins. The kind of join is determined by which data.table is considered `x` and which `y`.

```{r}
# right join using compact form
diet[family, on = "binomial"]

# left join
family[diet, on = "binomial"]

# inner join requires an na.omit
na.omit(
  family[diet, on = "binomial"]
)
```
