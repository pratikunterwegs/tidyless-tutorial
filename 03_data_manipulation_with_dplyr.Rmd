---
editor_options:
  chunk_output_type: console
---

# Data manipulation with `data.table`

```{r load_lib}
# load the tidyverse
library(data.table)
```

## Introduction

Through this tutorial, we will be using mammal trait data from the [Phylacine](https://megapast2future.github.io/PHYLACINE_1.2/) database.
Let's have a peek at what it contains.

```{r read_data, message=FALSE}
data <- fread("data/phylacine_traits.csv")
data
```

## Working with existing variables

### Renaming variables

Changing names is straightforward with `setnames`. This modifies the data.table in place. Columns need to be referred to as strings.

```{r rename}
# data.table setnames does not require assignment
setnames(data, old = "Binomial.1.2", new = "binomial")
```

If all the columns are being renamed, the `old =` and `new =` arguments can be dropped, and a single string for the new names is sufficient.

```{r rename3, echo=FALSE}
# get new names
new_names <- stringi::stri_replace_all_fixed(str = colnames(data),
                                       ".", "_")
new_names <- stringi::stri_replace_all_fixed(new_names, "_1_2", "")
new_names <- stringi::stri_trans_tolower(new_names)

# set new names
setnames(
  x = data,
  new_names
)

# check colnames
colnames(data)
```

### Three ways of pulling variables

Columns can be pulled from a data.table or data.frame by name using the `[[` operator.

*NB*: Pulling a data.table in this way returns a one-column data.table, NOT a vector. Convert the data.table to a vector if that is what you require.
On the other hand, pulling a column in this way from a data.frame returns a vector. The difference is important to keep in mind.

```{r}
# returns a single column data.table
data[, "binomial"]

# returns a vector
head(
  data[["binomial"]]
)

# returns a vector
data$binomial

# returns a vector
head(
  setDF(data)[, "binomial"] # note the changed class
)
```

In the lines above we used the `setDF` command which converts the data.table into a regular data.frame. This happens in-place, i.e, the result does not need to be assigned to an oject.
The `setDT` function is the opposite, converting a data.frame to a data.table.

### Selecting variables

Selecting variables is done by passing a list-like object to the data.table.
Columns can be renamed while selecting by passing a named list.

```{r select}
# select columns using a character vector
data[, c("binomial", "order", "family")]

# select using non-standard evaluation
data[, .(binomial, order, family)]

# select using a list
data[, list(binomial, order)]

# rename while selecting by passing a named list
data[, list(species = binomial, species_order = order)]
```

It is not really possible to remove columns from a data.table by appending a `-` sign; instead the variables have to be set to `NULL`, which is the same as it would be for a data.frame. The example below shows how.

```{r exclude}
# we remove one variable
data[, diet_source := NULL]

colnames(data)
```

### Select variables by pattern

Selecting variables sharing parts of their names is relatively easy using the `stringi` package.

```{r select_help}
# select diet information by pattern
names_to_select <- stringi::stri_subset(colnames(data), fixed ="diet")
data[, ..names_to_select]
```

## Working with observations

### Ordering rows by value

`setorder` sorts rows in the data by **ascending** value for a given variable.
Use the argument `order = 1 OR -1` to sort by ascending or descending values (with ascending as default).

`setorder` and the related `setorderv` operate _in place_, and are thus memory efficient. It also means that you need to be careful when 'just testing' something out --- the order is changed when you use the command. Moreover, the order of other pointers to the data is also changed, unless they have a distinct memory location.

```{r}
# mammals ordered by mass
setorder(data, mass_g)[, c("binomial", "mass_g")]

# Largest mammals first
setorderv(data, "mass_g", order = -1)[, c("binomial", "mass_g")]

# sorting by multiple variables
setorder(data, mass_g, diet_plant)[, c("binomial", "mass_g", "diet_plant")]
```

### Subset rows by position

Subsetting by rows works the same as with a regular data frame or a matrix. Simply pass the row numbers to the LHS of the comma within the square brackets.

```{r}
# here we sample five rows of the columns species and family
data[sample(nrow(data), 5), c("binomial", "family")]
```

### Filtering a data.table

Data.tables have no inbuilt filter function, but are filtered by passing either a list-like of rows to be retained (or discarded) or a logical vector of whether corresponding rows should be retained.

```{r megafauna}
# megafauna with the condition mass > 100 g
data[mass_g > 1e7, c("binomial", "mass_g")]

# non-extinct megafauna
data[mass_g > 1e5 & iucn_status != "EP", c("binomial", "mass_g")]

```

Are there any flying mammals that aren't bats?

```{r no_bats}
# flying mammals that are not bats
data[aerial & order != "Chiroptera", ]

# no :(
```

Are humans included in the table?

```{r human_after_all}
data[binomial == "Homo sapiens", ]
```

`NA`s can be filtered out this way.

```{r filter_na}
head(
  data[!is.na(mass_comparison), mass_comparison]
)
```

`data.table` provides %between% and `between()`, which return a logical for whether the value is between the limits or not.

```{r between}
between(1:5, 2, 4)

# fitler for mesofauna
data[between(mass_g, 1e3, 1e5), c("binomial", "mass_g")]
```

## Making new variables

### The internal assignment operator `:=`

Very often in data analysis, you will want to create new variables, or edit
existing ones. This is done easily through `:=`. This modified the data.table in place, making it more memory efficient.

```{r}
# pull the diet columns
# see the regex chapter for how to work with regular expression
diet_cols <- c(stringi::stri_subset(colnames(data), 
                                    regex = "(diet)(?!.*method|source)"),
               "binomial")

data[, ..diet_cols]
```

These three variables show the percentage of each category of food that make the
diet of that species. They should sum to 100, unless the authors made a typo or
other entry error. To assert this, I'm going to create a new variable,
`total_diet`.

```{r total_diet}
# make a copy so the original is not modified
diet_data <- copy(data[, ..diet_cols])

# get rowsums except for species name
diet_data[, total_diet := 
            rowSums(diet_data[, !"binomial"])]

all(diet_data$total_diet == 100)
# cool and good
```

If you want to keep only the new variable, you'll have to set the old variables to `NULL` after calculating the new variable.

```{r diet_animal}
# do operation
diet_data[, diet_animal := diet_vertebrate + diet_invertebrate]

# subset columns and save them to new object
diet_data[, binomial, diet_animal]
```

### Summarise observations with `summarise()`

`mutate()` applies operations to all observations in a table. By contrast,
`summarise()` applies operations to *groups* of observations, and returns, er,
summaries. The default grouping unit is the entire table:

```{r summarise}
phylacine %>%
  summarise(
    "nb_species" = n(), # counts observations
    "nb_terrestrial" = sum(terrestrial),
    "nb_marine" = sum(marine),
    "nb_freshwater" = sum(freshwater),
    "nb_aerial" = sum(aerial),
    "mean_mass_g" = mean(mass_g)
  )
```

Above you can see that bats account for a large portion of mammal species
diversity (`nb_aerial`). How much exactly? Just as with `mutate()`, you can
perform operations on the variables you just created, in the same statement:

```{r prop_bats}
phylacine %>%
  summarise(
    "nb_species" = n(),
    "nb_aerial" = sum(aerial), # bats
    "prop_aerial" = nb_aerial / nb_species
  )
```

One fifth!

If the british spelling bothers you, `summarize()` exists and is strictly
equivalent.

Here's a simple trick with logical (TRUE / FALSE) variables. Their sum is the
count of observations that evaluate to `TRUE` (because `TRUE` is taken as 1 and
`FALSE` as 0) and their mean is the proportion of `TRUE` observations. This can
be exploited to count the number of observations that satisfy a condition:

```{r sum_logi}
phylacine %>%
  summarise(
    "nb_species" = n(),
    "nb_megafauna" = sum(mass_g > 100000),
    "p_megafauna" = mean(mass_g > 100000)
  )

```

There are more summaries that just means and counts
(see `?summarise()` for some helpful functions). In fact, summarise can
use any function or expression that evaluates to a single value or a *vector*
of values. This includes base R `max()`, `quantiles`, etc.

`mutate()` and `transmute()` can compute summaries as well, but they will
return the summary once for each observation, in a new column.

```{r mutate_summary}
phylacine %>%
  mutate("nb_species" = n()) %>%
  select(binomial, nb_species)
```

### Grouping observations by variables

In most cases you don't want to run summary operations on the entire set of observations, but instead on observations that share a common value, i.e. groups.
For example, I want to run the summary displayed above, but for each Order of mammals.

`distinct()` extracts all the unique values of a variable

```{r distinct_orders}
phylacine %>% distinct(order)
```

I could work my way with what we have already seen, filtering observations (`filter(order == "Rodentia")`) and then pipeing the output to `summarise()`, and do it again for each Order. But that would be tedious.

Instead, I can use `group_by()` to pool observations by `order`.

```{r group_by_order}
phylacine %>%
  group_by(order)
```

At first glance, nothing has changed, apart from an extra line of information in the output that tells me the observations have been grouped. But now here's what happen if I run the same `summarise()` statement on an ungrouped and a grouped table

```{r summarise_order}
phylacine %>%
  summarise(
    "n_species" = n(),
    "mean_mass_g" = mean(mass_g)
  )

phylacine %>%
  group_by(order) %>%
  summarise(
    "n_species" = n(),
    "mean_mass_g" = mean(mass_g)
  )
```

I get one value for each group.

Observations can be grouped by multiple variables, which will output a summary for every unique combination of groups.

```{r multiple_groups}
phylacine %>%
  group_by(order, iucn_status) %>%
  summarise(
    "n_species" = n()
  )
```

Whenever you call `summarise()`, the last level of grouping is dropped. Note how in the output table above, observations are still grouped by order, and no longer by IUCN status. If I summarise observations again:

```{r drop_grouping}
phylacine %>%
  group_by(order, iucn_status) %>%
  summarise(
    "n_species" = n()
  ) %>%
  summarise(
    "n_species_2" = n()
  )
```

I get the summary across orders, and the table is no longer grouped at all. This is useful to consider if you need to work on summaries across different levels of the data.

For example, I would like to know how the species in each order are distributed between the different levels of threat in the IUCN classification. To get these proportions, I need to first get the count of each number of species in a level of threat inside an order, and divide that by the number of species in that order.

```{r iucn_prop}
phylacine %>%
  group_by(order, iucn_status) %>%
  summarise("n_order_iucn" = n()) %>%
  # grouping by iucn_status silently dropped
  mutate(
    "n_order" = sum(n_order_iucn),
    "p_iucn" = n_order_iucn / n_order
  )
```

10.2% of Carnivores are Endangered ("EN").

### Grouped data and other `dplyr` verbs

Grouping does not only affect the behaviour of `summarise`, but under circumstances, other verbs can (and will!) perform operations by groups.

```{r grouped_filter}
# Species with a higher mass than the mammal mean
phylacine %>%
  select("binomial", "mass_g") %>%
  filter(mass_g > mean(mass_g, na.rm = TRUE))

# Species with a higher mass than the mean in their order
phylacine %>%
  group_by(order) %>%
  select("binomial", "mass_g") %>%
  filter(mass_g > mean(mass_g, na.rm = TRUE))

```

```{r grouped_slice}
# Largest mammal
phylacine %>%
  select(binomial, mass_g) %>%
  slice_max(mass_g)
# Largest species in each order
phylacine %>%
  group_by(order) %>%
  select(binomial, mass_g) %>%
  slice_max(mass_g)
```

To avoid grouped operations, you can simply drop grouping with `ungroup()`.

## Working with multiple tables

### Binding tables

`dplyr` introduces `bind_rows()` and `bind_cols()`, which are equivalent to base
R `rbind()` and `cbind()`, with a few extra feature. They are faster, and can
bind many tables at once, and bind data frames with vectors or lists.

`bind_rows()` has an option to pass a variable specifying which dataset each
observation originates from.

```{r id_bind}
porpoises <- phylacine %>%
  filter(family == "Phocoenidae") %>%
  select(binomial, iucn_status)
echidnas <- phylacine %>%
  filter(family == "Tachyglossidae") %>%
  select(binomial, iucn_status)

bind_rows(
  "porpoise" = porpoises,
  "echidna" = echidnas,
  .id = "kind"
)
```

### Combining variables of two tables with mutating joins

Mutating joins are tailored to combine tables that share a set of observations
but have different variables.

As an example, let's split the `phylacine` dataset in two smaller datasets,
one containing information on diet and one on the dominant habitat.

```{r split_phylacine}
diet <- phylacine %>%
  select(binomial, diet_plant:diet_invertebrate) %>%
  slice(1:5)
diet

life_habit <- phylacine %>% select(binomial, terrestrial:aerial) %>%
  slice(1:3, 6:7)
life_habit

```

The two datasets each contain 5 species, the first three are shared, and the
two last differ between the two.

```{r intersect}
intersect(diet$binomial, life_habit$binomial)
setdiff(diet$binomial, life_habit$binomial)
```

To use mutate-joins, both tables need to have a **key**, a variable that
identifies each observation. Here, that would be `binomial`, the sepcies names.
If your table doesn't have such a key and the rows between the tables match
one another, remember you can create a row number variable easily with
`tibble::column_to_rownames()`.

```{r inner_join}
inner_join(diet, life_habit, by = "binomial")
```

`inner_join` combined the variables, and dropped the observations that weren't
matched between the two tables. There are three other variations of mutating
joins, differing in what they do with unmatching variables.

```{r outer_joins}
left_join(diet, life_habit, by = "binomial")
right_join(diet, life_habit, by = "binomial")
full_join(diet, life_habit, by = "binomial")

semi_join(diet, life_habit, by  = "binomial")
anti_join(diet, life_habit, by  = "binomial")
```

### Filtering matching observations between two tables wiht filtering joins

So-called filtering joins return row from the first table that are matched
(or not, for `anti_join()`) in the second.

```{r filter_joins}
semi_join(diet, life_habit, by  = "binomial")
anti_join(diet, life_habit, by  = "binomial")
```
