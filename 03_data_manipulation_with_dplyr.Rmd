---
editor_options: 
  chunk_output_type: console
---

# Data manipulation with `dplyr`

```{r load_lib}
# load the tidyverse
library(tidyverse)
```

## Introduction

Reminders from last weeks: pipe operator, tidy tables, ggplot

Why dplyr ? dplyr vs base R

## Example data of the day

Through this tutorial, we will be using mammal trait data from the [Phylacine](https://megapast2future.github.io/PHYLACINE_1.2/) database. The dataset contains information on mass, diet, life habit, etc, for more than all living species of mammals. Let's have a look.

```{r read_data, message=FALSE}
phylacine <- readr::read_csv("data/phylacine_traits.csv")
phylacine
```

Note the friendly output given by the `tibble` (as opposed to a `data.frame`). `readr` automatically stores the content it reads in a `tibble`, tidyverse oblige. You should know however that `dplyr` doesn't require your data to be in a tibble, a regular `data.frame` will work just as fine.

Most of the `dplyr` verbs covered in the next sections assume your data is *tidy*: wide format, variables as column, 1 observation per row. If that's not the case of your
dataset, refer to the tools introduced in Chapter 2 (`tidyr`) of this tutorial.
Fortunately, the phylacine trait dataset appears to be tidy: there is one unique entry for each species.

The first operation I'm going to run on this table is changing the names with
`rename()`. Some people prefer their tea without sugar, I [prefer](https://style.tidyverse.org/syntax.html#object-names) my 
variable names without uppercase characters, dots or (when possible) numbers. 
This will give me a chance to introduce the trivial syntax of `dplyr` verbs.

```{r rename}
phylacine <- dplyr::rename(
  .data = phylacine, 
  "binomial" = Binomial.1.2,
  "order" = Order.1.2,
  "family" = Family.1.2,
  "genus" = Genus.1.2,
  "species" = Species.1.2,
  "terrestrial" = Terrestrial,
  "marine" = Marine,
  "freshwater" = Freshwater,
  "aerial" = Aerial,
  "life_habit_method" = Life.Habit.Method,
  "life_habit_source" = Life.Habit.Source,
  "mass_g" = Mass.g,
  "mass_method" = Mass.Method,
  "mass_source" = Mass.Source,
  "mass_comparison" = Mass.Comparison,
  "mass_comparison_source" = Mass.Comparison.Source,
  "island_endemicity" = Island.Endemicity,
  "iucn_status" = IUCN.Status.1.2, # not even for acronyms
  "added_iucn_status" =  Added.IUCN.Status.1.2,
  "diet_plant" = Diet.Plant,
  "diet_vertebrate" = Diet.Vertebrate,
  "diet_invertebrate" = Diet.Invertebrate,
  "diet_method" = Diet.Method,
  "diet_source" = Diet.Source
)
```

The first argument is always `.data`, the data table (`data.frame` or `tibble`) you want to apply change to. 
Note how columns are referred to. Once the data table as been passed as an argument,
there is no need to refer to it directly anymore, `dplyr` understands that you're dealing with variables inside that data frame. So drop that `data$var`, `data[, "var"]`,
and forget the very existence of `attach()` / `detach()`. 

Finally, I should mention that you can refer to variables names either with strings or directly as objects, whether you're reading or creating them:

```{r rename2, eval=FALSE}
phylacine2 <- readr::read_csv("data/phylacine_traits.csv")

dplyr::rename(
  phylacine2,
  # this works
  binomial = Binomial.1.2
)
dplyr::rename(
  phylacine2,
  # this works too!
  binomial = "Binomial.1.2"
)
dplyr::rename(
  phylacine2,
  # guess what
  "binomial" = "Binomial.1.2"
)
```

## The pipe operator `%>%`
If you have already come across pieces of code using the tidyverse, chances are 
that you have seen this odd symbol. While the pipe is no strictly-speaking a
part of the tidyverse (it comes from its own package, `magrittr`), it is 
imported along with each package and widely used in conjunction with its 
functions.
What does it do? Consider the following example with `rename()`:

```{r the_pipe}
phylacine2 <- readr::read_csv("data/phylacine_traits.csv")
# regular syntax
dplyr::rename(
  phylacine2,
  "binomial" = "Binomial.1.2"
)
# alternative syntax with the pipe operator
phylacine2 %>% 
  dplyr::rename(
    "binomial" = "Binomial.1.2"
  )
```

Got it? The pipe takes the object on its left-side and silently feeds it to the
*first* argument of the function on its right-side. It could be read as "take x,
then do...".
The reason for using the pipe is because it makes code syntax closer to 
the syntax of a sentence, and therefore, easier and faster for your brain to
process (and write!) the code. In particular, the pipe enables easy chains of 
operations, where you apply something to an object, then apply something else to
the outcome, and so on...
I will show some examples of chained operations with tidyverse functions, but
for that I first need to introduce a couple more verbs.

Using the pipe can be quite unsettling at first, because you're not used to
think in this way. But if you push a bit for it, I promise it will make things
a lot easier, and it's strangely addicting. To avoid typing the tedious symbols,
`magrittr` installs a shortcut for you in RStudio. Use `Ctrl + Shift + M` on 
Windows, and `Cmd + Shift + M` on MacOS.

Finally I should emphasize that the use of the pipe isn't limited to the 
tidyverse, but extends to almost all R functions. Just remember that the piped
value is always matched to the first argument of the following function

```{r pipe_examples}
5 %>% rep(3)
"meow" %>% cat()
```

If you need to pass the left-hand side to an argument other than the first,
you can use the dot place-holder `.`.

```{r dot}
"meow" %>% cat("cats", "go", .)
```

Because of its syntax, most base R operators are not compatible with the pipe (but this is very rarely needed). If needed, `magrittr` introduces alternative functions for operators.

Subsetting operators can be piped, with the dot place-holder.

```{r pipe_limits}
# 5 %>% * 3 # no, won't work
# 5 %>% .* 3 # neither
5 %>% magrittr::multiply_by(3) # yes

# subsetting
list("monkey see", "monkey_do") %>% .[[2]]
phylacine %>% .$binomial %>% head()
```

## Select variables with `select()`

To extract a set of variables (i.e. columns), use the conveniently-named `select()`.

```{r select}
phylacine_subset <- phylacine %>% 
  dplyr::select(
    binomial, 
    order, 
    terrestrial, 
    marine, 
    freshwater, 
    aerial
  )
phylacine_subset
# Single variable
phylacine %>% dplyr::select(family)
# A set of variables
phylacine %>% dplyr::select(genus, species, mass_g)
# A range of variables
phylacine %>% dplyr::select(family:terrestrial)
```

`select()` can also be used to *exclude* variables:

```{r exclude}
phylacine %>% dplyr::select(-binomial)
phylacine %>% dplyr::select(-(binomial:species))
```

`select()` and `rename()` are pretty similar, and in fact, `select()` can also rename variables along the way:

```{r select_rename}
phylacine %>% dplyr::select("fam" = family)
```

And you can mix all of that at once:

```{r select_mix}
phylacine %>% dplyr::select(
  "fam" = family,
  genus:freshwater,
  -terrestrial
)
```

## Select observations with `filter()`

Conditional selection of observations is performed through `filter()`. This i sarguably the most useful function in the entire package. The syntax uses conditions involving the variables, just as you would use for `if` statements or `while` loops.

For example, I might want to extract mammals that are above a certain mass:

```{r megafauna}
# megafauna
phylacine %>% 
  dplyr::filter(mass_g > 1e5) # 100 kg
# living megafauna
phylacine %>% 
  dplyr::filter(mass_g > 1e5, iucn_status != "EP")

# Are there any flying mammals besides bats?
phylacine %>% 
  dplyr::filter(aerial == 1, order != "Chiroptera") 
# no :(

# That one species
phylacine %>% dplyr::filter(binomial == "Homo_sapiens")

```

Tip: `dplyr` introduces the useful function `between()` that does exactly what the name implies

```{r between}
between(1:5, 2, 4)

# Mesofauna
phylacine %>% dplyr::filter(mass_g > 1e3, mass_g < 1e5) # base
phylacine %>% dplyr::filter(mass_g %>% between(1e3, 1e5)) # dplyr

```

Note that you can absolutely pipe operations inside function arguments as above (those are expressions, after all!).

If instead of selecting observations based on conditions, you want to get the nth row, use `slice()`

```{r slice}
phylacine %>% dplyr::slice(1:3)
# can also be used to exclude rows
phylacine %>% 
  dplyr::slice(1:3) %>% 
  dplyr::slice(-2) 
```

## Create new variables with `mutate()`

Often in data analysis, you will want to create new variables, or edit existing
ones. This is done easily through `mutate()`. For example, consider the diet 
data:

```{r}
diet <- phylacine %>% 
  dplyr::select(
    binomial,
    diet_plant,
    diet_vertebrate,
    diet_invertebrate
  )
diet
```

These three variables show the percentage of each category of food that make the
diet of that species. They should sum to 100. To assert this, I'm going to 
create a new variable, `total_diet`.

```{r total_diet}
diet <- diet %>% dplyr::mutate(
  "total_diet" = diet_vertebrate + diet_invertebrate + diet_plant
)
diet

all(diet$total_diet == 100)
```

`mutate()` adds a variable to the table, and keeps all other variables. 
Sometimes you may want to just keep the new variable, and drop the other ones.
That's the job of `mutate()`'s twin sibling, `transmute()`. For example,
I want to combine `diet_invertebrate` and `diet_vertebrate`

```{r diet_animal}
diet %>% 
  dplyr::transmute(
    "diet_animal" = diet_invertebrate + diet_vertebrate
  )
```

You may want to keep some variables and drop others. You could pipe `mutate()` and `select()` to do so, or you could just pass the variables to keep to `transmute()`.

```{r both_diets}
diet %>% 
  dplyr::transmute(
    "diet_animal" = diet_invertebrate + diet_vertebrate,
    diet_plant
  )
```

You can also refer to variables you're creating to derive new variables from them as part of the same operation, this is not an issue.

```{r total_diet2}
diet %>% 
  dplyr::transmute(
    "diet_animal" = diet_invertebrate + diet_vertebrate,
    diet_plant,
    "total_diet" = diet_animal + diet_plant
  )
```

Sometimes, you may need to perform an operation based on the row number.
To add the row number as a variable, you could do:

```{r row_nb}
phylacine %>% 
  dplyr::transmute(
    binomial,
    "row_nb" = 1:nrow(phylacine)
  )
```

but `tibble` has a built-in function to do just that:

```{r row_index}
phylacine %>% 
  dplyr::select(binomial) %>% 
  tibble::rownames_to_column(var = "row_nb")
```

## Grouped operations with `summarise()` and `group_by()`

### Summarise observations

`mutate()` applies operations to all observations in a table. By contrast, `summarise()` applies operations to *groups* of observations, by default, all of them:

```{r summarise}
phylacine %>% 
  dplyr::summarise(
    "n_species" = dplyr::n(),
    "n_terrestrial" = sum(terrestrial),
    "n_marine" = sum(marine),
    "n_freshwater" = sum(freshwater),
    "n_aerial" = sum(aerial),
    "mean_mass_g" = mean(mass_g)
  )
```

Above you can see that bats account for a large portion of mammal species diversity (`n_aerial`). How much exactly? Just as with `mutate()`, you can perform operations on the variables you just created, in the same statement:

```{r prop_bats}
phylacine %>% 
  dplyr::summarise(
    "n_species" = dplyr::n(),
    "n_aerial" = sum(aerial), # bats
    "prop_aerial" = n_aerial / n_species
  )
```

One fifth!
If the british spelling bothers you, worry not. `summarize()` also exists, and is strictly equivalent. That's how thoughtful the folks at RStudio are.

Logical (TRUE/FALSE) variables can be used for a simple trick. Their sum is the count of observations that evaluate to `TRUE`, (because `TRUE` is taken as 1 and `FALSE` as 0) and their mean is the proportion of `TRUE` observations. This can be exploited to count the number of observations that satisfy a condition:

```{r sum_logi}
phylacine %>% 
  dplyr::summarise(
    "nb_species" = dplyr::n(),
    "nb_megafauna" = sum(mass_g > 100000),
    "p_megafauna" = mean(mass_g > 100000)
  )
```

See `?summarise()` for more examples of functions to use with `summarise()`: spread, range, position... 

### Grouping by variables

In most cases you don't want to run summary operations on the entire set of observations, but instead on observations that share a common feature, i.e. groups.
For example, I want to run the summary displayed above, but for each Order of mammals instead of the entire set as one block.
I could work my way with what we have already seen, filtering observations (`filter(order == "Rodentia")`) and then pipeing the output to `summarise()`, and do it again for each Order. But that would be tedious.

Instead, I can use `group_by()` to pool observations by `order`.

```{r group_by_order}
phylacine %>% 
  dplyr::group_by(order)
```

At first glance, nothing has changed, apart from an extra line of information in the output. But now here's what happen if I run the same `summarise()` statement on an ungrouped and a grouped table

```{r summarise_order}
phylacine %>% 
  dplyr::summarise(
    "n_species" = dplyr::n(),
    "mean_mass_g" = mean(mass_g)
  )

phylacine %>% 
  dplyr::group_by(order) %>% 
  dplyr::summarise(
    "n_species" = dplyr::n(),
    "mean_mass_g" = mean(mass_g)
  )
```

Observations can be grouped by multiple variables, outputting a summary for every combination.

```{r multiple_groups}
phylacine %>% 
  dplyr::group_by(order, iucn_status) %>% 
  dplyr::summarise(
    "n_species" = dplyr::n()
  )
```

Whenever you call `summarise()`, the last level of grouping is dropped. Note how in the output table above, observations are grouped by order, and no longer by IUCN status. If I summarise observations again:

```{r drop_grouping}
phylacine %>% 
  dplyr::group_by(order, iucn_status) %>% 
  dplyr::summarise(
    "n_species" = dplyr::n()
  ) %>% 
  dplyr::summarise(
    "n_species_2" = dplyr::n()
  )
```

I get the summary across orders, and the table is no longer grouped at all. This is useful to consider if you need to work on summaries across different levels of the data. For example, I would like to know how the members of each order are distributed among the different levels of threat in the IUCN classification. To get these proportions, I need to first get the count of each number of species in a level of threat inside an order, and divide that by the number of species in that order.

```{r iucn_prop}
iucn_props <- phylacine %>% 
  dplyr::group_by(order, iucn_status) %>% 
  dplyr::summarise("n_order_iucn" = dplyr::n()) %>% 
  # grouping by iucn_status silently dropped
  dplyr::mutate(
    "n_order" = sum(n_order_iucn),
    "p_iucn" = n_order_iucn / n_order
  )
iucn_props

iucn_props %>% 
  dplyr::filter(order == "Carnivora")
```

10.2% of all Carnivores are in the category "Endangered (EN)".

Just above I used `mutate()` instead of `summarise()`. In fact, `mutate()` (and `transmute()`) can generally perform summaries just like `summarise()`. The difference is that `summarise()` will return one value per group, while `mutate()` returns one value per observation.

```{r mutate_for_summaries}
sirenia <- phylacine %>% 
  dplyr::filter(order == "Sirenia") %>% 
  dplyr::select(binomial)
sirenia

sirenia %>% 
  dplyr::summarise("n" = dplyr::n())
sirenia %>% 
  dplyr::mutate("n" = dplyr::n())

```

## Joining tables


## More !
arrange
.$
variables values -> dplyr::distinct() eq. to base::unique()
sample_n()
sample_frac()
dplyr:: ?

