---
editor_options: 
  chunk_output_type: console
---

# Data manipulation with `dplyr`

```{r load_lib}
# load the tidyverse
library(tidyverse)
```

verbs

## Foreword on data

Through this tutorial, we will be using mammal trait data from the [Phylacine](https://megapast2future.github.io/PHYLACINE_1.2/) database.
Let's have a peek at what it contains.

```{r read_data, message=FALSE}
phylacine <- read_csv("data/phylacine_traits.csv")
phylacine
```

`readr` automatically loads the data in a `tibble`, as we have seen in chapter
1 and 2. Calling the tibble gives a nice preview of what it contains. We have 
data for 5,831 mammal species, and the variables contain information on taxonomy,
(broad) habitat, mass, IUCN status, and diet.

If you remember Section 1.2 on tidy data, you may see that this data isn't 
exactly tidy. In fact, some columns are in wide (and messy) format, like the 
"habitat" (terrestrial, marine, etc.) and diet columns. 

`dplyr` does not require your data to be strictly tidy. If you feel that your
data satisfies the definition "one observation per row, one variable per column",
you are probably good to go. 

I use a `tibble` here, but `dplyr` works equally well on base `data.frame`s. In
fact, `dplyr` is built for `data.frame` objects, and `tibble`s are `data.frame`s.
Ergo, Socrates is a dog.

## Working with existing variables

Through this section, I'm going to rework the table a little bit before running any kinf of operation on it.

First, the variable names are descriptive, but quite unpractical. Typing `Binomial.1.2.` is cumbersome and subject to typos (in fact, I just made one). `binomial` would be much simpler to use.

Second, there are a lot of variables that I am not going to use, like the metadata (`Life.Habit.Method`), so I'm going to select a subset of the data.

### Renaming variables

Changing names is straightforward with `rename()`.

```{r rename}
rename(
 .data = phylacine, 
 "binomial" = Binomial.1.2,
)
```

The first argument is always `.data`, the data table you want to apply change to. 
Note how columns are referred to. Once the data table as been passed as an argument, there is no need to refer to it directly anymore, `dplyr` understands that you're dealing with variables inside that data frame. So drop that `data$var`, `data[, "var"]`,
and forget the very existence of `attach()` / `detach()`. 

You can refer to variables names either with strings or directly as objects, whether you're reading or creating them:

```{r rename2, eval=FALSE}
rename(
  phylacine,
  # this works
  binomial = Binomial.1.2
)
rename(
  phylacine,
  # this works too!
  binomial = "Binomial.1.2"
)
rename(
  phylacine,
  # guess what
  "binomial" = "Binomial.1.2"
)
```

I have applied similar changes to all variables in the dataset. Here is what the
new names look like:

```{r rename3, include=FALSE, echo=TRUE}
phylacine <- rename(
  .data = phylacine, 
  "binomial" = Binomial.1.2,
  "order" = Order.1.2,
  "family" = Family.1.2,
  "genus" = Genus.1.2,
  "species" = Species.1.2,
  "terrestrial" = Terrestrial,
  "marine" = Marine,
  "freshwater" = Freshwater,
  "aerial" = Aerial,
  "life_habit_method" = Life.Habit.Method,
  "life_habit_source" = Life.Habit.Source,
  "mass_g" = Mass.g,
  "mass_method" = Mass.Method,
  "mass_source" = Mass.Source,
  "mass_comparison" = Mass.Comparison,
  "mass_comparison_source" = Mass.Comparison.Source,
  "island_endemicity" = Island.Endemicity,
  "iucn_status" = IUCN.Status.1.2, # not even for acronyms
  "added_iucn_status" =  Added.IUCN.Status.1.2,
  "diet_plant" = Diet.Plant,
  "diet_vertebrate" = Diet.Vertebrate,
  "diet_invertebrate" = Diet.Invertebrate,
  "diet_method" = Diet.Method,
  "diet_source" = Diet.Source
)
phylacine
```

### The pipe operator `%>%`

If you have already come across pieces of code using the tidyverse, chances are 
that you have seen this odd symbol. While the pipe is not strictly-speaking a
part of the tidyverse (it comes from its own package, `magrittr`), it is 
imported along with each package and widely used in conjunction with its 
functions.
What does it do? Consider the following example with `rename()`:

```{r the_pipe}
phylacine2 <- readr::read_csv("data/phylacine_traits.csv")
# regular syntax
rename(
  phylacine2,
  "binomial" = "Binomial.1.2"
)
# alternative syntax with the pipe operator
phylacine2 %>% 
  rename(
    "binomial" = "Binomial.1.2"
  )
```

Got it? The pipe takes the object on its left-side and silently feeds it to the
*first* argument of the function on its right-side. It could be read as "take x,
then do...".
The reason for using the pipe is because it makes code syntax closer to 
the syntax of a sentence, and therefore, easier and faster for your brain to
process (and write!) the code. In particular, the pipe enables easy chains of 
operations, where you apply something to an object, then apply something else to
the outcome, and so on...
I will show some examples of chained operations with tidyverse functions, but
for that I first need to introduce a couple more verbs.

Using the pipe can be quite unsettling at first, because you're not used to
think in this way. But if you push a bit for it, I promise it will make things
a lot easier (and it's quite addictive!). To avoid typing the tedious symbols,
`magrittr` installs a shortcut for you in RStudio. Use `Ctrl + Shift + M` on 
Windows, and `Cmd + Shift + M` on MacOS.

Finally I should emphasize that the use of the pipe isn't limited to the 
tidyverse, but extends to almost all R functions. Remember that by default
the piped value is always matched to the first argument of the following 
function

```{r pipe_examples}
5 %>% rep(3)
"meow" %>% cat()
```

If you need to pass the left-hand side to an argument other than the first,
you can use the dot place-holder `.`.

```{r dot}
"meow" %>% cat("cats", "go", .)
```

Because of its syntax, most base R operators are not compatible with the pipe (but this is very rarely needed). If needed, `magrittr` introduces alternative functions for operators.

Subsetting operators can be piped, with the dot place-holder.

```{r pipe_limits}
# 5 %>% * 3 # no, won't work
# 5 %>% .* 3 # neither
5 %>% magrittr::multiply_by(3) # yes

# subsetting
list("monkey see", "monkey_do") %>% .[[2]]
phylacine %>% .$binomial %>% head()
```

Because subsetting in this way is particularly hideous, `dplyr`
delivers a function to extract values from a single variable. In only works on tables, though.

```{r pull}
phylacine %>% pull(binomial) %>% head()
```

### Selecting variables with `select()`

To extract a set of variables (i.e. columns), use the conveniently-named 
`select()`. The basic syntax is the same as `rename()`: pass your data as the 
first argument, then call the variables to select, quoted or not.

```{r select}
# Single variable
phylacine %>% select(binomial)
# A set of variables
phylacine %>% select(genus, "species", mass_g)
# A range of contiguous variables
phylacine %>% select(family:terrestrial)
```

You can select by variable numbers. This is not recommended, as prone to 
errors, especially if you change the variable order.

```{r select_nb}
phylacine %>% select(2)
```

`select()` can also be used to *exclude* variables:

```{r exclude}
phylacine %>% select(-binomial)
phylacine %>% select(-(binomial:species))
```

`select()` and `rename()` are pretty similar, and in fact, `select()` can also rename variables along the way:

```{r select_rename}
phylacine %>% select("linnaeus" = binomial)
```

And you can mix all of that at once:

```{r select_mix}
phylacine %>% select(
  "fam" = family,
  genus:freshwater,
  -terrestrial
)
```

### Select variables with helpers

The Rstudio team just released `dplyr 1.0.0`, and along with it, some nice helper functions to ease the selection of a set of variables. I give three examples here, and encourage you to look at the documentation (`?select()`) to
find out more.

```{r select_help}
phylacine %>% select(where(is.numeric))
phylacine %>% select(contains("mass") | contains("diet"))

habitats <- c("terrestrial", "marine", "arboreal", "fossorial", "freshwater")
phylacine %>% select(any_of(habitats))

```

## Working with observations

### Select observations with `filter()`

Conditional selection of observations is performed through `filter()`. This i sarguably the most useful function in the entire package. The syntax uses conditions involving the variables, just as you would use for `if` statements or `while` loops.

For example, I might want to extract mammals that are above a certain mass:

```{r megafauna}
# megafauna
phylacine %>% 
  filter(mass_g > 1e5) # 100 kg
# living megafauna
phylacine %>% 
  filter(mass_g > 1e5, iucn_status != "EP")

# Are there any flying mammals besides bats?
phylacine %>% 
  filter(aerial == 1, order != "Chiroptera") 
# no :(

# That one species
phylacine %>% filter(binomial == "Homo_sapiens")

```

Tip: `dplyr` introduces the useful function `between()` that does exactly what the name implies

```{r between}
between(1:5, 2, 4)

# Mesofauna
phylacine %>% filter(mass_g > 1e3, mass_g < 1e5) # base
phylacine %>% filter(mass_g %>% between(1e3, 1e5)) # dplyr

```

Note that you can absolutely pipe operations inside function arguments as above (those are expressions, after all!).

If instead of selecting observations based on conditions, you want to get the nth row, use `slice()`

```{r slice}
phylacine %>% slice(1:3)
# can also be used to exclude rows
phylacine %>% 
  slice(1:3) %>% 
  slice(-2) 
```

## Operations on the data

### Create new variables with `mutate()`

Often in data analysis, you will want to create new variables, or edit existing
ones. This is done easily through `mutate()`. For example, consider the diet 
data:

```{r}
diet <- phylacine %>% 
  select(
    binomial,
    diet_plant,
    diet_vertebrate,
    diet_invertebrate
  )
diet
```

These three variables show the percentage of each category of food that make the
diet of that species. They should sum to 100. To assert this, I'm going to 
create a new variable, `total_diet`.

```{r total_diet}
diet <- diet %>% mutate(
  "total_diet" = diet_vertebrate + diet_invertebrate + diet_plant
)
diet

all(diet$total_diet == 100)
```

`mutate()` adds a variable to the table, and keeps all other variables. 
Sometimes you may want to just keep the new variable, and drop the other ones.
That's the job of `mutate()`'s twin sibling, `transmute()`. For example,
I want to combine `diet_invertebrate` and `diet_vertebrate`

```{r diet_animal}
diet %>% 
  transmute(
    "diet_animal" = diet_invertebrate + diet_vertebrate
  )
```

You may want to keep some variables and drop others. You could pipe `mutate()` and `select()` to do so, or you could just pass the variables to keep to `transmute()`.

```{r both_diets}
diet %>% 
  transmute(
    "diet_animal" = diet_invertebrate + diet_vertebrate,
    diet_plant
  )
```

You can also refer to variables you're creating to derive new variables from them as part of the same operation, this is not an issue.

```{r total_diet2}
diet %>% 
  transmute(
    "diet_animal" = diet_invertebrate + diet_vertebrate,
    diet_plant,
    "total_diet" = diet_animal + diet_plant
  )
```

Sometimes, you may need to perform an operation based on the row number.
To add the row number as a variable, you could do:

```{r row_nb}
phylacine %>% 
  transmute(
    binomial,
    "row_nb" = 1:nrow(phylacine)
  )
```

but `tibble` has a built-in function to do just that:

```{r row_index}
phylacine %>% 
  select(binomial) %>% 
  tibble::rownames_to_column(var = "row_nb")
```

### Grouped operations with `summarise()` and `group_by()`

#### Summarise observations

`mutate()` applies operations to all observations in a table. By contrast, `summarise()` applies operations to *groups* of observations, by default, all of them:

```{r summarise}
phylacine %>% 
  summarise(
    "n_species" = n(),
    "n_terrestrial" = sum(terrestrial),
    "n_marine" = sum(marine),
    "n_freshwater" = sum(freshwater),
    "n_aerial" = sum(aerial),
    "mean_mass_g" = mean(mass_g)
  )
```

Above you can see that bats account for a large portion of mammal species diversity (`n_aerial`). How much exactly? Just as with `mutate()`, you can perform operations on the variables you just created, in the same statement:

```{r prop_bats}
phylacine %>% 
  summarise(
    "n_species" = n(),
    "n_aerial" = sum(aerial), # bats
    "prop_aerial" = n_aerial / n_species
  )
```

One fifth!
If the british spelling bothers you, worry not. `summarize()` also exists, and is strictly equivalent. That's how thoughtful the folks at RStudio are.

Logical (TRUE/FALSE) variables can be used for a simple trick. Their sum is the count of observations that evaluate to `TRUE`, (because `TRUE` is taken as 1 and `FALSE` as 0) and their mean is the proportion of `TRUE` observations. This can be exploited to count the number of observations that satisfy a condition:

```{r sum_logi}
phylacine %>% 
  summarise(
    "nb_species" = n(),
    "nb_megafauna" = sum(mass_g > 100000),
    "p_megafauna" = mean(mass_g > 100000)
  )
```

See `?summarise()` for more examples of functions to use with `summarise()`: spread, range, position... 

#### Grouping by variables

In most cases you don't want to run summary operations on the entire set of observations, but instead on observations that share a common feature, i.e. groups.
For example, I want to run the summary displayed above, but for each Order of mammals instead of the entire set as one block.
I could work my way with what we have already seen, filtering observations (`filter(order == "Rodentia")`) and then pipeing the output to `summarise()`, and do it again for each Order. But that would be tedious.

Instead, I can use `group_by()` to pool observations by `order`.

```{r group_by_order}
phylacine %>% 
  group_by(order)
```

At first glance, nothing has changed, apart from an extra line of information in the output. But now here's what happen if I run the same `summarise()` statement on an ungrouped and a grouped table

```{r summarise_order}
phylacine %>% 
  summarise(
    "n_species" = n(),
    "mean_mass_g" = mean(mass_g)
  )

phylacine %>% 
  group_by(order) %>% 
  summarise(
    "n_species" = n(),
    "mean_mass_g" = mean(mass_g)
  )
```

Observations can be grouped by multiple variables, outputting a summary for every combination.

```{r multiple_groups}
phylacine %>% 
  group_by(order, iucn_status) %>% 
  summarise(
    "n_species" = n()
  )
```

Whenever you call `summarise()`, the last level of grouping is dropped. Note how in the output table above, observations are grouped by order, and no longer by IUCN status. If I summarise observations again:

```{r drop_grouping}
phylacine %>% 
  group_by(order, iucn_status) %>% 
  summarise(
    "n_species" = n()
  ) %>% 
  summarise(
    "n_species_2" = n()
  )
```

I get the summary across orders, and the table is no longer grouped at all. This is useful to consider if you need to work on summaries across different levels of the data. For example, I would like to know how the members of each order are distributed among the different levels of threat in the IUCN classification. To get these proportions, I need to first get the count of each number of species in a level of threat inside an order, and divide that by the number of species in that order.

```{r iucn_prop}
iucn_props <- phylacine %>% 
  group_by(order, iucn_status) %>% 
  summarise("n_order_iucn" = n()) %>% 
  # grouping by iucn_status silently dropped
  mutate(
    "n_order" = sum(n_order_iucn),
    "p_iucn" = n_order_iucn / n_order
  )
iucn_props

iucn_props %>% 
  filter(order == "Carnivora")
```

10.2% of all Carnivores are in the category "Endangered (EN)".

Just above I used `mutate()` instead of `summarise()`. In fact, `mutate()` (and `transmute()`) can generally perform summaries just like `summarise()`. The difference is that `summarise()` will return one value per group, while `mutate()` returns one value per observation.

```{r mutate_for_summaries}
sirenia <- phylacine %>% 
  filter(order == "Sirenia") %>% 
  select(binomial)
sirenia

sirenia %>% 
  summarise("n" = n())
sirenia %>% 
  mutate("n" = n())

```

## Joining tables


## More
arrange
.$
variables values -> distinct() eq. to base::unique()
sample_n()
sample_frac()
 ?

