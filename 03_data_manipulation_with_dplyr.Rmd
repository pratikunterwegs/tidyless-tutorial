---
editor_options:
  chunk_output_type: console
---

# Data manipulation with `data.table`

```{r load_lib}
# load the tidyverse
library(data.table)
```

## Introduction

Through this tutorial, we will be using mammal trait data from the [Phylacine](https://megapast2future.github.io/PHYLACINE_1.2/) database.
Let's have a peek at what it contains.

```{r read_data, message=FALSE}
data <- fread("data/phylacine_traits.csv")
data
```

## Working with existing variables

### Renaming variables

Changing names is straightforward with `setnames`. This modifies the data.table in place. Columns need to be referred to as strings.

```{r rename}
# data.table setnames does not require assignment
setnames(data, old = "Binomial.1.2", new = "binomial")
```

If all the columns are being renamed, the `old =` and `new =` arguments can be dropped, and a single string for the new names is sufficient.

```{r rename3, echo=FALSE}
# get new names
new_names <- stringi::stri_replace_all_fixed(str = colnames(data),
                                       ".", "_")
new_names <- stringi::stri_replace_all_fixed(new_names, "_1_2", "")
new_names <- stringi::stri_trans_tolower(new_names)

# set new names
setnames(
  x = data,
  new_names
)

# check colnames
colnames(data)
```

### Three ways of pulling variables

Columns can be pulled from a data.table or data.frame by name using the `[[` operator.

*NB*: Pulling a data.table in this way returns a one-column data.table, NOT a vector. Convert the data.table to a vector if that is what you require.
On the other hand, pulling a column in this way from a data.frame returns a vector. The difference is important to keep in mind.

```{r}
# returns a single column data.table
data[, "binomial"]

# returns a vector
head(
  data[["binomial"]]
)

# returns a vector
data$binomial

# returns a vector
head(
  setDF(data)[, "binomial"] # note the changed class
)

# reset to data.table
setDT(data)
```

In the lines above we used the `setDF` command which converts the data.table into a regular data.frame. This happens in-place, i.e, the result does not need to be assigned to an oject.
The `setDT` function is the opposite, converting a data.frame to a data.table.

### Selecting variables

Selecting variables is done by passing a list-like object to the data.table.
Columns can be renamed while selecting by passing a named list.

```{r select}
# select columns using a character vector
data[, c("binomial", "order", "family")]

# select using non-standard evaluation
data[, .(binomial, order, family)]

# select using a list
data[, list(binomial, order)]

# rename while selecting by passing a named list
data[, list(species = binomial, species_order = order)]
```

It is not really possible to remove columns from a data.table by appending a `-` sign; instead the variables have to be set to `NULL`, which is the same as it would be for a data.frame. The example below shows how.

```{r exclude}
# we remove one variable
data[, diet_source := NULL]

colnames(data)
```

### Select variables by pattern

Selecting variables sharing parts of their names is relatively easy using the `stringi` package.

```{r select_help}
# select diet information by pattern
names_to_select <- stringi::stri_subset(colnames(data), fixed ="diet")
data[, ..names_to_select]
```

## Working with observations

### Ordering rows by value

`setorder` sorts rows in the data by **ascending** value for a given variable.
Use the argument `order = 1 OR -1` to sort by ascending or descending values (with ascending as default).

`setorder` and the related `setorderv` operate _in place_, and are thus memory efficient. It also means that you need to be careful when 'just testing' something out --- the order is changed when you use the command. Moreover, the order of other pointers to the data is also changed, unless they have a distinct memory location.

```{r}
# mammals ordered by mass
setorder(data, mass_g)[, c("binomial", "mass_g")]

# Largest mammals first
setorderv(data, "mass_g", order = -1)[, c("binomial", "mass_g")]

# sorting by multiple variables
setorder(data, mass_g, diet_plant)[, c("binomial", "mass_g", "diet_plant")]
```

### Subset rows by position

Subsetting by rows works the same as with a regular data frame or a matrix. Simply pass the row numbers to the LHS of the comma within the square brackets.

```{r}
# here we sample five rows of the columns species and family
data[sample(nrow(data), 5), c("binomial", "family")]
```

### Filtering a data.table

Data.tables have no inbuilt filter function, but are filtered by passing either a list-like of rows to be retained (or discarded) or a logical vector of whether corresponding rows should be retained.

```{r megafauna}
# megafauna with the condition mass > 100 g
data[mass_g > 1e7, c("binomial", "mass_g")]

# non-extinct megafauna
data[mass_g > 1e5 & iucn_status != "EP", c("binomial", "mass_g")]
```

Are there any flying mammals that aren't bats?

```{r no_bats}
# flying mammals that are not bats
data[aerial & order != "Chiroptera", ]

# no :(
```

Are humans included in the table?

```{r human_after_all}
data[binomial == "Homo sapiens", ]
```

`NA`s can be filtered out this way.

```{r filter_na}
head(
  data[!is.na(mass_comparison), mass_comparison]
)
```

`data.table` provides %between% and `between()`, which return a logical for whether the value is between the limits or not.

```{r between}
between(1:5, 2, 4)

# fitler for mesofauna
data[between(mass_g, 1e3, 1e5), c("binomial", "mass_g")]
```

## Making new variables

### The internal assignment operator `:=`

Very often in data analysis, you will want to create new variables, or edit
existing ones. This is done easily through `:=`. This modified the data.table in place, making it more memory efficient.

```{r}
# pull the diet columns
# see the regex chapter for how to work with regular expression
diet_cols <- c(stringi::stri_subset(colnames(data), 
                                    regex = "(diet)(?!.[method|source])"),
               "binomial")

data[, ..diet_cols]
```

These three variables show the percentage of each category of food that make the
diet of that species. They should sum to 100, unless the authors made a typo or
other entry error. To assert this, I'm going to create a new variable,
`total_diet`.

```{r total_diet}
# make a copy so the original is not modified
diet_data <- copy(data[, ..diet_cols])

# get rowsums except for species name
diet_data[, total_diet := 
            rowSums(diet_data[, !"binomial"])]

all(diet_data$total_diet == 100)
# cool and good
```

If you want to keep only the new variable, you'll have to set the old variables to `NULL` after calculating the new variable.

```{r diet_animal}
# do operation
diet_data[, diet_animal := diet_vertebrate + diet_invertebrate]

# subset columns and save them to new object
diet_data[, binomial, diet_animal]
```

### Summarising variables

To get summary values within groups, the general syntax for a data.table is shown below with an example.

**General syntax**

`dt[, .(summary_var = function(existing_var)), by = .(grouping_var)]`

When no grouping variables are supplied, values are summarised over the entire data.table.

```{r summarise}
data[, .(nb_species = .N,
         nb_terrestrial = sum(terrestrial),
         nb_marine = sum(marine),
         nb_freshwater = sum(freshwater),
         nb_aerial = sum(aerial),
         mean_mass_g = mean(mass_g))]
```

### Summarising within groups

Summarising within groups is very easily done by passing one or more column names to the `by = ` argument.

```{r summarise_order}
# get a species count and mean mass by order
data[, .(n_species = .N,
         mean_mass_g = mean(mass_g)),
     by = .(order)]

# passing a list is equivalent to using the .
# renaming on the fly is supported
data[, list(n_species = .N,
         mean_mass_g = mean(mass_g)),
     by = list(mammal_order = order)]
```

Observations can be grouped by multiple variables, which will output a summary for every unique combination of groups.

```{r multiple_groups}
# group by order and family
data[, list(n_species = .N,
         mean_mass_g = mean(mass_g)),
     by = list(mammal_order = order,
               mammal_family = family)]
```

Operation chaining is easily done.

```{r iucn_prop}
# operation chaining is possible but not recommended
head(                                             # showing only the top rows
  setorder(                                       # arranging by order
    data[, list(n_order_iucn = .N),               # counting order-iucnn sums
         by = list(order, iucn_status)
         ][, n_order := sum(n_order_iucn),        # counting order wise species
           by = order
           ][, p_iucn := n_order_iucn / n_order], # get proportions
    order
  )
)
```

## Working with multiple tables

### Binding tables

`data.table` provides the `rbindlist` function to bind data.tables row or column wise.

```{r id_bind}
# get porpoises
porpoises <- data[family == "Phocoenidae", list(binomial, iucn_status)]
echidnas <- data[family == "Tachyglossidae", list(binomial, iucn_status)]

# bind into a single data.table
rbindlist(l = list(porpoises = porpoises, 
                   echidnas = echidnas),
          idcol = "kind")
```

### Combining variables of two tables with mutating joins

Mutating joins are tailored to combine tables that share a set of observations
but have different variables.

In the example below, the data is split into habitat and diet data, recombined by species.

```{r split_phylacine}
# get species and diet data
cols_wanted <- c("binomial",
                 stringi::stri_subset(colnames(data), regex = "(diet)(?!.[source|method])"))
# get diet
diet <- data[seq(5), ..cols_wanted]

life_habit <- phylacine %>% select(binomial, terrestrial:aerial) %>%
  slice(1:3, 6:7)
life_habit

```

The two datasets each contain 5 species, the first three are shared, and the
two last differ between the two.

```{r intersect}
intersect(diet$binomial, life_habit$binomial)
setdiff(diet$binomial, life_habit$binomial)
```

To use mutate-joins, both tables need to have a **key**, a variable that
identifies each observation. Here, that would be `binomial`, the sepcies names.
If your table doesn't have such a key and the rows between the tables match
one another, remember you can create a row number variable easily with
`tibble::column_to_rownames()`.

```{r inner_join}
inner_join(diet, life_habit, by = "binomial")
```

`inner_join` combined the variables, and dropped the observations that weren't
matched between the two tables. There are three other variations of mutating
joins, differing in what they do with unmatching variables.

```{r outer_joins}
left_join(diet, life_habit, by = "binomial")
right_join(diet, life_habit, by = "binomial")
full_join(diet, life_habit, by = "binomial")

semi_join(diet, life_habit, by  = "binomial")
anti_join(diet, life_habit, by  = "binomial")
```

### Filtering matching observations between two tables wiht filtering joins

So-called filtering joins return row from the first table that are matched
(or not, for `anti_join()`) in the second.

```{r filter_joins}
semi_join(diet, life_habit, by  = "binomial")
anti_join(diet, life_habit, by  = "binomial")
```
